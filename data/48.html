<!DOCTYPE html>
<html lang="en">
<head>
<title>Основы командной строки</title>
<meta charset="utf-8"/>
<link href="/assets/css/main.css" rel="stylesheet"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<link href="/assets/shower/themes/ribbon/styles/styles.css" rel="stylesheet"/>
<style>
        .shower {
            --slide-ratio: calc(16 / 12);
        }
    </style>
<style>

        html{
            background-color: #000;
        }

        body{
            min-height: 0;
            background-color: #000;
        }

        #cover h2 {
            margin: 30px 0 0;
            /*color: white;*/
            text-align: center;
            font-size: 70px;
        }

        #cover p {
            margin: 10px 0 0;
            text-align: center;
            color: white;
            font-style: italic;
            font-size: 12px;
        }

        #cover p a {
            /*color: white;*/
        }

        #temp {
            display: none;
            visibility: hidden;
        }

        section {
            font-size: 20px;
        }

        section h2 {
            font-size: 50px;
        }

        .slide{
            line-height: 1.2em;
            font-size: 1em;
        }

        .slide ol, .slide ul {
            line-height: 1em;
        }

        .slide pre {
            overflow-x: hidden; 
            overflow-y: hidden; 
            line-height: 1.2em;
            /*font-size: 1em;*/
        }

        img {
            max-height: 550px;
            width: auto;
        }

        img#cover{
            height: 100%;
            width: auto;
        }

        .slide .shout {
            font-size: 120px;
        }

        .mjx-chtml{
        	font-size: 25px !important;
        }

        section > div.presentation, section > img{
		  margin: 0;
		  position: absolute;
		  top: 460px;
		  left: 50%;
		  -ms-transform: translate(-50%, -50%);
		  transform: translate(-50%, -50%);
		}
    </style>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
	   MathJax.Hub.Config({
	     extensions: ["tex2jax.js"],
	     jax: ["input/TeX", "output/HTML-CSS"],
	     tex2jax: {
	       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	       processEscapes: true
	     },
	     "HTML-CSS": { availableFonts: ["TeX"] }
	   });
	</script>
</head>
<body class="shower list">
<div id="temp">
<h3 id="зачем-нужна-командная-строка">Зачем нужна командная строка?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-1.png" style="width: 900px;" title="image_tooltip"/></p>
<p>Командная строка - это основной способ взаимодействия с операционными системами семейства UNIX. Все современные дистрибутивы для общего пользования включают и графическое окружение, которое позволяет обычному пользователю работать в оконном интерфейсе, без освоения командного интерпретатора. Но при необходимость выполнения служебных действий, практически всегда приходится обращаться к командной строке.</p>
<p>Команды позволяют выполнить практически любой действие с операционной системой. В отличие от Windows, в Linux чем более продвинутый пользователь, тем чаще ему приходится залезать в командную строку. Профессионалы работают с ней постоянно. Именно поэтому мы с вами будем изучать ее, чтобы работа в терминале не пугала нас, а наоборот, мы чувствовали себя там комфортно.</p>
<p>Команды значительно более гибкие и мощные, нежели графические оболочки. Графический интерфейс сильно ограничивает ваши возможности по взаимодействию с системой: вы можете выполнить только определенные действия и только в определенном порядке. Используя команды оболочки, можно выполнять любые действия, предусмотренные командной оболочкой, запускать любые программы и комбинировать их в любой последовательности</p>
<p>Сейчас мы будем употреблять термины “командная строка”, “оболочка”, “терминал”, “bash” и “командный интерпретатор” как синонимы. Между ними есть определенная разница, но в самом начале, чтобы не путаться, можно не обращать на нее внимания. Все эти термины относятся к способу взаимодействия пользователя с системой через ввод текстовых команд. Вообще, в Linux существует много разных командных интерпретаторов, построенных на основе разных языков программирования. Но с большим отрывом самый популярный - это bash. Именно про него мы и будем говорить дальше.</p>
<p>Командная строка работает по принципу REPL. То есть вы вводите команду, нажимаете &lt;Enter&gt;, в этот момент она исполняется, результат выводится на экран и вы можете вводить следующую. Однако, следует помнить, что некоторые команды являются интерактивными, то есть они выполняются, пока пользователь их явно не прервет.</p>
<p>Недостаток командной строки - отсутствие интуитивного интерфейса. Для совершения определенного действия необходимо знать команду, которая это действие совершает. В графическом интерфейсе можно сориентироваться, даже если вы не знаете точно что нужно делать, вы можете догадаться по названиям пунктов меню, пиктограмм, расположению на экране. В командной строке не так, только вы и черный экран. Поэтому сначала надо изучить хотя бы основные команды, а уже потом начинать работать. Сразу скажем, что работа в командной строке поначалу может показаться непривычной и даже неудобной. Это нормально, ощущение дискомфорта уйдет в процессе привыкания. На самом деле совершать определенные действия в командной строке гораздо удобнее, чем тыкать в кнопочки. Недаром большинство профессиональных администраторов, программистов и ученых предпочитают работать текстом, даже если есть графический инструмент для нужного действия.</p>
<p>Самое главное достоинство командной строки - удобство автоматизации. Командная строка - это еще и язык программирования. Если вы часто совершаете однотипные действия в командной строке вы можете просто записать их в скрипт и выполнять его. Ведь каждая команда - это по сути дела строчка в программе. В скриптах вы можете делать еще кучу всего - использовать условия, циклы, функции. Вы можете обращаться к командной строке из своих программ, на любом языке программирования. То есть при помощи командной строки вы можете производить комплексную автоматизацию. А вот автоматизировать действия в графическом интерфейсе наоборот, невероятно сложно.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Для Linux командная строка - основной способ взаимодействия с пользователем.</li>
<li>Самый распространенный интерпретатор командной строки в Linux - bash.</li>
<li>Командная строка пугает, это нормально.</li>
<li>Самое главное достоинство командной строки - удобство автоматизации.</li>
</ol>
</div>
<h3 id="как-туда-попасть">Как туда попасть?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-2.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Изначально, терминал - это интерфейс ввода/вывода, состоящий из физических устройства ввода (клавиатура) и вывода (дисплей). Терминал предназначен исключительно для ввода информации и ее отображения на экране. Терминалы бывают физическими (реальными), виртуальными и псевдотерминалами (т.е. программами, которые “притворяются” терминалами). Не останавливаясь на подробностях работы реальных терминалов отметим, что при работе чаще всего вы будете использовать виртуальные терминалы и эмуляторы.</p>
<p>В системах Linux еще существуют несколько виртуальных терминалов. По умолчанию Линукс представляет доступ к шести текстовым терминалам, которые соответственно называются tty1, tty2 и т.д. Переключение между ними осуществляется сочетанием клавиш Ctrl+F1, Ctrl+F2, Ctrl+F3 и т.д. В современных дистрибутивах в одном из терминалов (обычно под номером 7) загружена графическая оболочка и этот терминал открывается по умолчанию. При загруженной графической оболочке открытие терминалов и переключение между ними производится клавишами Alt+Ctrl+Fn, (где n - номер терминала). Сама графическая оболочка будет доступна по Alt+Ctrl+F7. Для работы в каждом новом терминале вы должны прежде всего авторизоваться. Таким образом, в системе одновременно могут работать несколько различных пользователей, каждый в своем терминальном сеансе.</p>
<p>Если вы используете десктопный дистрибутив, то в одном из виртуальных терминалов запускается графическая оболочка. Именно он обычно и запускается по умолчанию. Поэтому при старте системы вы видите графический интерфейс. Но, кстати, для самой операционки, это просто такая специальная программа, запускаемая автоматически при загрузке в седьмом (обычно) виртуальном терминале</p>
<p>Самый простой способ - открыть программу-эмулятор терминала. В любой графической системе есть такая программа, которая открывает командную строку прямо в окне. Это удобно, так как не надо переключаться в другой терминал и логиниться там. Вы уже работаете в сеансе пользователя. Кроме того, такие программы-эмуляторы обычно содержат дополнительные функции, например, подсветку синтаксиса, масштабирование, прозрачность, вкладки.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Терминал в старой терминологии - конечное устройство ввода-вывода пользователя.</li>
<li>При запуске Linux создает несколько виртуальных терминалов.</li>
<li>Для того, чтобы начать работать с терминалом, нужно, залогиниться.</li>
<li>Существуют графические программы-эмуляторы терминала.</li>
<li>За разными терминалами могут работать разные пользователи. А может и один.</li>
</ol>
</div>
<h3 id="что-вы-видите-на-экране-командной-оболочки">Что вы видите на экране командной оболочки?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-3.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Когда вы открываете терминал, необходимо найти текущее положение курсора. Он обычно обозначается мигающей вертикальной чертой или знаком подчеркивания. Курсор обозначает то место, где будут появляться символы при их вводе с клавиатуры.</p>
<p>Все, что отображается в строке непосредственно перед курсором еще до того, как вы начали что-то вводить - это приглашение командной строки. Это строка определенного вида, которая отображается каждый раз перед вводом команды. Даже само ее название означает, что она приглашает вас ввести какую-нибудь команду. Если вы привыкли к виду приглашения командной строки, оно поможет вам ориентироваться в терминале. Кроме того, приглашение содержит некоторую полезную информацию.</p>
<p>Вид приглашения зависит от используемой оболочки и часто может настраиваться пользователем. Но мы пока рассмотрим стандартное приглашение оболочки по умолчанию. Оно обычно состоит из четырех частей.</p>
<p>Самым первым отображается имя текущего пользователя.</p>
<p>Далее после символа @ идет название текущего хоста (экземпляра операционной системы). Имя хоста обычно употреблаяется для обозначения текущего компьютера. Если вы работаете только за одним компьютером, вам может показаться, что это не очень полезное знание. Но в работе системного администратора часто возникает необходимость подключаться удаленно к разным хостам. И забыть, в консоли какого компьютера ты сейчас находишься - это не так странно, как может показаться.</p>
<p>Далее отображается имя текущей папки. Очень важный факт про консоль - в ней мы не можем находиться “просто так”, мы всегда находимся в какой-то папке на диске. Это имя “текущей директории”. Мы можем перемещаться между папками, или обращаться к файлам других папок, но в любой момент работы название текущей директории отображается в приглашении, чтобы мы всегда могли просто посмотреть, где мы сейчас.</p>
<p>Если вы только запустили терминал, то скорее всего находитесь в домашней папке. Она обозначается для краткости специальным символом ~. У каждого зарегистрированного пользователя есть своя домашняя папка.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Курсор в терминале - это то, куда вводить буквы с клавиатуры.</li>
<li>Приглашение командной строки - это полезная информация о вашем состоянии.</li>
<li>В приглашении по умолчанию отображается имя пользователя, имя хоста и текущая папка.</li>
<li>В терминале можно перемещаться по папкам.</li>
<li>Вид терминала и приглашения можно настраивать.</li>
</ol>
</div>
<h3 id="какие-команды-изучить-в-первую-очередь">Какие команды изучить в первую очередь?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-4.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Для работы в консоли необходимо знать команды. Интуитивным интерфейсом здесь не обойдешься. Изучение команд - это вопрос времени и практики. Чем больше вы работаете в системе, тем лучше ее знаете. Поэтому настоятельно рекомендуется как можно чаще пользоваться командной строкой в процессе изучения системы. Так вы сможете выработать привычку и освоить базовые команды не путем заучивания, а естественно.</p>
<p>90% вашего времени вы будете использовать самые базовые команды - переходы по папкам, создание и перемещение файлов и аналогичные. В этом разделе мы перечислим десять самых базовых команд, с которых удобнее всего начинать изучение командной строки и языка bash:</p>
<ol>
<li><em>pwd</em> (print working directory) - отобразить текущую директорию.</li>
<li><em>ls [&lt;dirname&gt;]</em> (list) - вывести список файлов и папок в текущей директории. В linux директории считаются наряду с обычными файлами. ls Desktop - вывести список файлов в другой директории.</li>
<li><em>cd [&lt;dirname&gt;]</em> (change directory) - изменить текущую директорию. Для удобства, чтобы не указывать у файлов и папок постоянно путь к ним из текущей директории, можно изменить текущую директорию на ту, с которой вы работаете сейчас.</li>
<li><em>cat &lt;filename&gt;</em> (concatenate) - вывести на консоль (в стандартный вывод) содержимое текстового файла, имя которого передано как параметр. Можно передать несколько файлов, тогда они “склеятся”</li>
<li><em>mkdir &lt;dirname&gt;</em> (make a directory) - создание директории (папки). Параметром передается имя новой папки. Папка создается в текущей директории. Если здесь уже есть файл или папка с таким именем, то команда завершится с ошибкой.</li>
<li><em>touch &lt;filename&gt;</em> - вообще данная команда обновляет дату и время последнего доступа к переданному файлу. Если такого файла нет, то файл будет создан. Чаще всего эта команда используется для создания новых пустых файлов.</li>
<li>_rm &lt;filename&gt; _(remove) - удаление файла. При помощи опций данная команда может удалять и директории. Обратите внимание, что удаление происходи насовсем. Никакая корхина в командной строке не предусмотрена. Поэтому этой командой надо пользоваться осторожно.</li>
<li><em>cp &lt;src&gt; &lt;dest&gt;</em> (copy) - копирование файла. Данной команде надо передать два параметра - имя копируемого файла и имя файла (возможно в другой папке), куда его необходимо скопировать. Очень часто в подобных случаях действует правило откуда - куда (сначала указывается имя исходного файла или папки, а потом - целевой папки или файла).</li>
<li><em>mv &lt;src&gt; &lt;dest&gt;</em> (move) - то же самое, только происходит не копирование, а перемещение файла. Если производить перемещение в ту же папку, где файл и был, он запишется с другим именем. Часто эта команда используется именно для переименования файлов.</li>
<li><em>man &lt;command&gt;</em> (manual) - получение справки по команде. Это, наверное, самая полезная команда, ей нужно пользоваться как можно чаще. Встроенная справка (мануал) - это самый главный, полный и актуальный источник информации о командах и их параметрах.</li>
</ol>
<h3 id="как-выполняются-команды">Как выполняются команды?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-5.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Каждая команда при своем выполнении (в тот момент, когда мы нажимаем Enter после самой команды) запускает определенный алгоритм, чаще всего - целую отдельную программу. Некоторые команды завершаются моментально (pwd), а другие (ping) - выполняются продолжительное время. Кроме того, некоторые команды запускают интерактивные программы (top). При работе с терминалом важно понимать, сколько будет выполняться та или иная команда.</p>
<p>Командная строка работает по принципу REPL (read - execute - print - loop), то есть после ввода команда тут же начинает выполняться, причем все, что эта команда выводит на печать отображается в том же терминале, в котором эта команда была введена. Поэтому для того, чтобы разные команды не смешивались, пока одна команда выполняется, она полностью блокирует собой этот терминал. То есть вы не сможете вводить другие команды, пока первая не завершится. После завершения команда освобождает занятый терминал, в нем автоматически снова выводится приглашение командной строки и цикл завершается, вы можете вводить следующую.</p>
<p>Большинство простых команд, таких как копирование файлов, создание директорий и другие, созданные для совершения одного определенного действия выполняются практически моментально. Большинство из этих команд - это стандартные служебные программы из проекта GNU, которые адаптировал существовавшее в UNIX рабочее окружение. Именно поэтому стандартные команды общие для всех дистрибутивов Linux, да и в других UNIX-подобных операционных системах они более-менее такие же.</p>
<p>Для таких простых стандартных команд часто действует определенная философия  - команда должна принимать входную информацию либо через параметры, либо читать из переданного файла, и выводить информацию в консоль только чтобы сообщить об ошибке. Таким образом, чаще всего данные команды завершаются мгновенно и не выводят ничего. И именно такое поведение свидетельствует о том, что необходимые действия совершены успешно. Но новички часто думают, что если команда ничего не вывела, то она по каким-то причинам не отработала. В UNIX зачастую это не так.</p>
<p>Конечно, существуют команды, цель которых отобразить информацию в терминале. Типичный пример - команда ls. Она выводит список файлов в каталоге. Естественно, она должна выводить его на свой стандартный вывод. Еще, существуют команды, которые работают долгое время и выводят много информации в терминал. Например, так устроена команда find - поиск файлов по имени, команда ping вообще будет работать неопределенно долго, пока пользователь сам явне не прервет ее.</p>
<p>Но в любом случае, такие неинтерактивные команды стараются как можно реже запрашивать информацию у пользователя через стандартный ввод. Это сделано специально для того, чтобы команды можно было объединять в конвейеры или скрипты, то есть программы. Строить программу их интерактивных блоков довольно сложно, а из простых “кирпичиков” - очень легко. И зачастую администраторам приходится писать такие служебные скрипты, что гораздо удобнее, чем каждый раз вводить несколько команд руками.</p>
<p>Отдельно надо сказать о так называемых интерактивных командах. Их очень немного, но они работают в совершенно особом режиме. После запуска они полностью занимают терминал, обычно еще и полностью очищают окно. Зачастую у них присутствует псевдографический интерфейс. И в процессе своей работы пользователь может взаимодействовать с ними при помощи их собственных сочетаний клавиш, каких-то внутренних команд до тех пор, пока не выйдет из этой программы и не вернется в привычный терминал. Примерами таких интерактивных команд может служить текстовый редактор nano или программа мониторинга системы top.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Команды выполняются по принципу REPL (как в IPython, например).</li>
<li>В процессе выполнения команды, все что она выведет будет отображаться в терминале.</li>
<li>После завершения команды вы опять увидите приглашение. Можно вводить следующую.</li>
<li>Пока выполнение команды не закончено, терминал является заблокированным.</li>
<li>Существуют интерактивные и неинтерактивные команды.</li>
<li>Большинство команд терминала - это стандартные программы из проекта GNU.</li>
<li>Если команда ничего не вывела и завершилась - значит все прошло успешно.</li>
</ol>
</div>
<h3 id="какие-приемы-работы-с-командной-строкой-существуют">Какие приемы работы с командной строкой существуют?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-6.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Для успешной и быстрой работы в командной строке существует большое количество сочетаний клавиш. Ознакомьтесь с ними на практике и попробуйте запомнить наиболее полезные:</p>
<p>&lt;Ctrl&gt;+&lt;C&gt; - завершение текущей команды; эта комбинация клавиш используется если вам нужно аварийно прервать выполняющуюся в терминале команду.</p>
<p>&lt;Ctrl&gt;+&lt;D&gt; - выход из текущего сеанса (разлогин);</p>
<p>&lt;Tab&gt; - подсказки и множественное дополнение; при вводе команды, имени файла не обязательно вводить с клавиатуры название целиком. Можно ввести первые несколько символов и нажать символ табуляции. Если есть только одна команда или один файл с таким именем, оно заполнится автоматически. Если же таких несколько, то при повторном нажатии табуляции вам будет предложены все возможные варианты и вы сможете продолжить ввод с клавиатуры.</p>
<p>clear, &lt;Ctrl&gt; + &lt;L&gt; - очистка экрана (перемотка вперед); можно использовать команду или сочетание клавиш, они работают совершенно идентично.</p>
<p>&lt;↑&gt; - переход к предыдущей команде. Вообще с помощью стрелок вверх и вниз можно перемещаться по истории ранее введенных команд. Это очень экономит время, если вы повторяете команды или изменяете уже введенные.</p>
<p>&lt;Ctrl&gt; + &lt;A&gt; - переход к началу команды; аналогично клавише &lt;Home&gt;.</p>
<p>&lt;Ctrl&gt; + &lt;E&gt; - переход к концу команды; аналогично клавише &lt;End&gt;.</p>
<p>&lt;Alt&gt; + &lt;F&gt;, &lt;Alt&gt; + &lt;B&gt; - переход к следующему и предыдущему слову в команде;</p>
<p>history - вывод истории команд в текущем сеансе;</p>
<p>sudo apt update ; apt upgrade - выполнение нескольких команд из одной строки;</p>
<p>&lt;Ctrl&gt; + &lt;R&gt; - поиск команды в истории; это бывает полезно, если вы уже вводили похожую команду, но не можете ее найти с помощью стрелок.</p>
<p>Это только самые основные комбинации, работающие в любом терминале Linux. Кроме этого разные оболочки могут вводить собственные сочетания клавиш, сокращения команд и другие фишки для экономии времени. Использование этих возможностей совершенно необязательно, но делает работу в командной строке гораздо быстрее и удобнее.</p>
<h3 id="какова-структура-команды">Какова структура команды?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-7.png" style="width: 750px;" title="image_tooltip"/></p>
<p>Любая команда оболочки состоит из одной или нескольких частей. Они разделяются пробелами. Основная часть, которая всегда идет первой при вводе команды - ее имя. Имя команды - обязательная часть. Нельзя выполнить команду не зная ее имени. Имя команды- чаще всего это название файла с исполняемым кодом этой команды. Например, ls - это имя команды. Точно так же имена других команд - cp. ps. top. firefox, многие другие.</p>
<p>Некоторые команды вполне обходятся только именем. Уже известная нам команда pwd - это команда, состоящая только из имени. Но у большинства команд кроме имени предусмотрены еще и другие элементы. Ключи или опции - это строки, которые могут быть указаны или отсутствовать и этим каким-то образом модифицировать порядок работы команды. У каждой команды свои опции, но в мире linux есть соглашения о стандартных опциях и их значениях.</p>
<p>Опции, они же ключи, - это необязательные строки, наличие или отсутствие которых при вызове команды как-то модифицирует ее поведение. Возьмем для примера команду ls. Будучи выполненной без опций она выводит список имен файлов, содержащихся в директории. Но у этой команды есть опция -l. Ее можно указать при вызове команды так: ls -l. То есть опции идут после имени команды через пробел. В таком виде эта команда также выведет список файлов в папке, но уже в табличном виде и с некоторой дополнительной информацией. Еще у команды ls есть опция -a - она заставит команду включить в список скрытые файлы, которые по умолчанию не отображаются.</p>
<p>Можно заметить, что опции состоят из одной буквы после дефиса. Это так называемый короткий формат опций. Есть еще и длинный. Например, опция -a полностью выглядит как –all. Короткие опции начинаются с одного дефиса и состоят из одной буквы. А длинные - начинаются с двух дефисов и состоят из одного или нескольких слов. Можно написать коротко, а можно и длинно, это одна и та же опция. Естественно, длинными опциями пользуются редко. Но иногда у команды может быть длинная опция, а короткого варианта нет, или наоборот.</p>
<p>Аргументы есть не у всех команд, указываются обычно после имени и опций. С помощью аргументов можно передать команде какую-то информацию на вход. Примерно так же, как мы передаем аргументы в функцию. Например, у той же команды ls есть необязательный аргумент - имя папки. Без аргументов эта команда отображает содержимое текущей папки, но можно заставить ее отобразить содержимое любой папки указав имя этой папки в качестве аргумента. Например, при вводе команды ls / будет отображены элементы, находящиеся в корневой папке, независимо от того, где мы сейчас находимся.</p>
<p>Аргументы бывают обязательные и необязательные в предыдущем примере аргумент можно и не указывать. А вот у команды cp есть целых два обязательных аргумента. Без них команда вообще не будет работать. Первый аргумент - это имя копируемого файла, а второй - имя папки, куда мы его копируем. Кроме этого у команды cp есть еще и опции.</p>
<p>Вообще, у каждой команды свой набор аргументов и опций и правил, в каком порядке нужно их указывать. Это называется синтаксис команды. Синтаксис команды задает разработчик команды при ее создании. Все, что мы описывали ранее - это не более чем набор общепринятых правил, традиционных для стандартных команд Linux. Но помните, что разработчики команд могут и проигнорировать эти правила. Например, в командах операционной системы BSD принято опции делать без дефиса. Поэтому у команды ps опции указываются именно так (ps a, ps aux). Самый лучший способ узнать синтаксис команды - прочитать официальную справку по ней.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>У любой команды есть имя - название программы - его вводить обязательно.</li>
<li>У команды могут быть обязательные или необязательные аргументы и необязательные опции.</li>
<li>Опции (ключи) могут модифицировать выполнение программы.</li>
<li>Опции бывают длинные и короткие. Короткие начинаются с одного дефиса, длинные - с двух.</li>
<li>Опции команды можно комбинировать, а короткие опции можно объединять.</li>
<li>Аргументы команды - это как аргументы функции - служат для указания входных данных.</li>
<li>Синтаксис команды зависит от ее разработчика и про него можно почитать в справке.</li>
</ol>
</div>
<h3 id="где-получить-помощь">Где получить помощь?</h3>
<p><img alt="alt_text" class="align-center" src="/assets/images/os_text/lx10-8.png" style="width: 750px;" title="image_tooltip"/></p>
<p>При работе с командной строкой приходится постоянно обращаться к документации. Невозможно постоянно держать в голове все команды, нюансы их использования, синтаксис. Поэтому в саму командную строку встроена официальная документация по системным командам. Эта официальная документация называется мануалы, man. Эти мануалы пишут разработчики команд и держат в актуальном виде.</p>
<p>Для доступа к официальным мануалам существует команда man. Есть еще несколько информационных команд (например, info), которые могут различаться от дистрибутива к дистрибутиву. Но man до сих пор остается основным источником информации про синтаксис команд. Посмотреть справку по команде, например, pwd, можно так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>man <span class="nb">pwd</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Мы получим полную и актуальную справку (мануал) по команде pwd, включая все возможные ее ключи и опции. Команда man может показать мануал по любой команде bash.</p>
<p>Рекомендуется пользоваться именно этой документацией потому, что синтаксис команд может меняться. В разных дистрибутивах, например, могут быть немного различающиеся наборы стандартных команд. Также синтаксис меняется от версии к версии, с изменением и доработкой самих команд и их окружения. Поэтому именно мануалы покажут вам справку именно по вашей команде именно нужной версии.</p>
<p>Конечно, для того, чтобы почитать мануалы, нужно знать само имя команды. К счастью, мануалы - не единственный источник информации. По всем распространенным командам достаточно легко получить справку и примеры использования в интернете. Существует большое количество тематических справочников, форумов, сообществ пользователей и разработчиков. И чем популярнее дистрибутив вы используете, тем больше про него будет информации. Учебники, справочную литературу тоже не стоит сбрасывать со счетов.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Для всех стандартных команд существует официальная справка.</li>
<li>Команды и их синтаксис могут меняться в разных дистрибутивах и версиях.</li>
<li>Первый источник информации - команда man.</li>
<li>Также информацию можно получить в интернете, на форумах, в учебниках.</li>
</ol>
</div>
</div>
<header class="caption">
<h1>Основы командной строки</h1>
<!-- <p>Yours Truly, Famous Inc.</p> -->
</header>
<section class="slide">
<h2 class="shout">Основы командной строки</h2>
</section>
<footer class="badge">
<a href="https://github.com/shower/shower">Build with shower</a>
</footer>
<script src="/assets/shower/shower.js"></script>
<!-- Copyright © 3000 Yours Truly, Famous Inc. -->
<script type="text/javascript">
        
        const content = document.querySelector('#temp');
        const childern = content.childNodes;

        let current_slide;
        let points;
        let code;
        let image;
        let misc;

        function commit() {
            if (current_slide) {

                const elems = [image, code, points, misc];

                let slide;

                elems.forEach(elem => {
                    if (elem) {
                        // console.log("ИТЕРАЦИЯ " + current_slide);
                        // console.log([image, code, points, misc]);

                        slide = document.createElement('section');
                        slide.className = "slide";
                        let slide_header = document.createElement('h2');
                        slide_header.innerHTML = current_slide;
                        slide.appendChild(slide_header);

                        slide.appendChild(elem);

                        document.body.appendChild(slide);

                        fit_in_slide(elem);
                    }
                });

                misc = undefined;
                points = undefined;
                image = undefined;
                code = undefined;
            }
        }

        function fit_in_slide(element) {
            console.log("ИТЕРАЦИЯ " + current_slide);
            console.log(element);

            let ratio = Math.min(
            	550 / element.offsetHeight,
            	// 1600 / element.offsetWidth,
            	);


            let new_size = Math.sqrt(ratio) / 1.2;
            if (new_size > 2.5) {
                new_size = 2.5
            }
            element.style["font-size"] = new_size + "em";

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            ratio = Math.min(
            	550 / element.offsetHeight,
            	1600 / element.offsetWidth,
            	);

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            console.log(element.innerHTML);            
            console.log(element.querySelectorAll("*"));            
            console.log(element.querySelectorAll("pre"));

            element.querySelectorAll("pre").forEach(e => {
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            element.querySelectorAll("span").forEach(e => {
            	console.log("found");
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            console.log(
                // realHeight, ratio, 
                new_size, 
                element.offsetHeight,
                element.offsetWidth);

            return element;
        }

        childern.forEach(elem => {
            if (elem.tagName == "H3") {
                commit();
                let slide = document.createElement('section');
                slide.className = "slide";
                let slide_header = document.createElement('h2');
                slide_header.className = "shout shrink"
                slide_header.innerHTML = elem.innerHTML;
                slide.appendChild(slide_header);

                // slide.appendChild(elem);

                document.body.appendChild(slide);
            }

            if (elem.tagName == "H3" || elem.tagName == "H4") {
                commit();
                current_slide = elem.innerHTML;
            }

            else if (elem.tagName == "DIV" && elem.classList.contains("notice--info")) {
                let list = elem.getElementsByTagName('ol')[0];

                list.childNodes.forEach(elem => {
                    elem.className = "next";
                });

                points = list;
                // points = fit_in_slide(points);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("highlighter-rouge")) {
                code = elem;
                commit()
                // code = fit_in_slide(code);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("presentation")) {
                misc = elem;
                // misc = fit_in_slide(misc);
                commit();
            } 

            else if (elem.tagName == "P" && elem.getElementsByTagName('img').length > 0) {
                image = elem.getElementsByTagName('img')[0];
                image.style.width = "auto";
                commit();
            } 
        });

        commit();

        content.remove();

    </script>
<div class="progress"></div>
<script src="/assets/js/main.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1K09X3NDBE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1K09X3NDBE', { 'anonymize_ip': false});
</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(77706580, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img alt="" src="https://mc.yandex.ru/watch/77706580" style="position:absolute; left:-9999px;"/></div></noscript>
<!-- /Yandex.Metrika counter -->
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</body>
</html>
