<!DOCTYPE html>
<html lang="en">
<head>
<title>Управление файлами в Linux</title>
<meta charset="utf-8"/>
<link href="/assets/css/main.css" rel="stylesheet"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<link href="/assets/shower/themes/ribbon/styles/styles.css" rel="stylesheet"/>
<style>
        .shower {
            --slide-ratio: calc(16 / 12);
        }
    </style>
<style>

        html{
            background-color: #000;
        }

        body{
            min-height: 0;
            background-color: #000;
        }

        #cover h2 {
            margin: 30px 0 0;
            /*color: white;*/
            text-align: center;
            font-size: 70px;
        }

        #cover p {
            margin: 10px 0 0;
            text-align: center;
            color: white;
            font-style: italic;
            font-size: 12px;
        }

        #cover p a {
            /*color: white;*/
        }

        #temp {
            display: none;
            visibility: hidden;
        }

        section {
            font-size: 20px;
        }

        section h2 {
            font-size: 50px;
        }

        .slide{
            line-height: 1.2em;
            font-size: 1em;
        }

        .slide ol, .slide ul {
            line-height: 1em;
        }

        .slide pre {
            overflow-x: hidden; 
            overflow-y: hidden; 
            line-height: 1.2em;
            /*font-size: 1em;*/
        }

        img {
            max-height: 550px;
            width: auto;
        }

        img#cover{
            height: 100%;
            width: auto;
        }

        .slide .shout {
            font-size: 120px;
        }

        .mjx-chtml{
        	font-size: 25px !important;
        }

        section > div.presentation, section > img{
		  margin: 0;
		  position: absolute;
		  top: 460px;
		  left: 50%;
		  -ms-transform: translate(-50%, -50%);
		  transform: translate(-50%, -50%);
		}
    </style>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
	   MathJax.Hub.Config({
	     extensions: ["tex2jax.js"],
	     jax: ["input/TeX", "output/HTML-CSS"],
	     tex2jax: {
	       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	       processEscapes: true
	     },
	     "HTML-CSS": { availableFonts: ["TeX"] }
	   });
	</script>
</head>
<body class="shower list">
<div id="temp">
<h3 id="как-организована-структура-каталогов-linux">Как организована структура каталогов Linux?</h3>
<p><img alt="styled-image" class="align-center" src="/assets/images/os_text/lx13-1.png" style="width: 800px;" title="Linux directory structure"/></p>
<p>Одно из самых базовых понятий для любой операционной системы - это файл. Обычно, мы подразумеваем под файлом некоторое количество информации, хранящееся в постоянном хранилище (на диске), имеющее имя. Однако, Linux построена таким образом, что практически любой объект, с которым работает операционная система является файлом. Привычные нам файлы здесь называются обычными, но кроме них еще существует несколько типов, которые Linux также называет файлами, хотя с точки зрения обывателя они воспринимаются как что-то другое. Например, любое физическое устройство имеет в операционной системе особое логическое представление в виде файла в определенной папке. Вы можете зайти в эту папку и просмотреть список устройств, зайти в конкретный файл и увидеть свойства этого устройства. Однако это не просто статическая информация, хранящиеся на диске. Это динамический объект операционной системы, на диске он не занимает никакого места, его там нет. При обращении к этому файлу происходит вызов особых функция ядра ОС. Кроме этого для Linux папки, ссылки (аналог ярлыков), даже процессы самой ОС - тоже файлы.</p>
<p>Это сделано для унификации доступа к различным ресурсам операционной системы. Зачем придумывать особый механизм отправки документов на печать, если можно просто записать текст в файл принтера. Такой подход может немного запутывать сначала, но довольно быстро привыкаешь, что для Linux практически любой объект - это файл. Но довольно часто приходится оговариваться, имеется в виду файл в узком смысле, обычный файл, как информация на диске с именем, или в широком смысле, как концепция операционной системы.</p>
<p>Понятно, что файлов в каждой отдельно взятой операционной системе может быть огромное количество. И только малая часть из этого - файлы пользователей. Кроме этого существуют служебные файлы операционной системы, конфигурационные файлы, файлы системных и прикладных программ, псевдофайлы, которые мы обсуждали ранее. Если бы файлы имели только имя, ориентироваться в этой куче было бы решительно невозможно. Для этого и нужны папки. Папки, они же директории или каталоги, служат для объединения произвольного количества файлов во множество в некоторым именем. Неудивительно, что для Linux папка - это тоже файл, его особый тип. Фактически, папка - это файл, содержащий список других файлов, которые в считаются “в этой папке”. Так что сами папки тоже можно “класть” в другие папки. Таким образом, структура файлов и папок образует иерархическую структуру-  дерево файловой системы.</p>
<p>А что происходит с файлами и папками, которые не  находятся в других папках? В Linux существует специальная корневая папка. Она обозначается прямым слешем (/). Она является вершиной этой иерархии, корнем дерева, единой точкой отсчета для всех других папок на данном компьютере. Так что любой файл находится в какой-то папке, либо в в корневой директории, либо в каком-то каталоге, который может быть в другом каталоге, и так далее, но в итоге все равно в корневой папке.</p>
<p>Таким образом, для того чтобы указать на какой-то конкретный файл нам недостаточно его имени, еще нужен его “адрес” - путь от корневой директории по (возможно нескольким) вложенным папкам до самого файла. Такой адрес называется “путь” к файлу. У каждого файла, который находится в операционной системе существует один и только один абсолютный путь от корневой директории. Заметьте, кстати, что конкретный файл не может находится в нескольких разных папках одновременно, то есть в двух местах сразу.</p>
<p>Все пути в Linux отсчитываются от корня файловой системы, обозначаемого прямым слешем /. Корень всегда один, не существует никаких букв дисков, как в Windows. Корень еще называют корневой папкой или директорией, так как именно в нем содержаться все другие папки. В пути к файлу последовательно указываются папки, которые нужно пройти, чтобы найти файл, а затем - имя самого файла. Имена папок и файла разделяются прямым слешем. Так, в пути /etc/passwd первый символ / обозначает корневой каталог, etc - имя папки в корневом каталоге, passwd - имя нужного нам файла. Обратите внимание, что в Linux не принято использовать расширения в именах файлов (но, впрочем, и не запрещено, так что ими многие пользуются).</p>
<p>В корневой папке обычно не хранятся обычный файлы, только папки. Причем папки корневой директории несут особую смысловую нагрузку. Например, каталог /etc/ хранит текстовые конфигурационные файлы самой операционной системы, а каталог /dev/ - те самые псевдофайлы-устройства, о которых мы уже упоминали. Этот набор стандартных папок немного меняется от дистрибутива к дистрибутиву, но основные остаются общими. Существует даже специальный стандарт - Lnux FHS (filesystem hierarchy standard), который и описывает набор и предназначение стандартных папок корневой директории.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Для Linux практически любой объект - файл.</li>
<li>В Linux файлы организованы привычным образом в папки и подпапки, образуя иерархическую структуру - дерево файловой системы.</li>
<li>Корневая папка / - это единая точка отсчета для всех папок.</li>
<li>Каждый файл имеет один и только один адрес в файловой системе - абсолютный путь к нему.</li>
<li>Для разделения имен папок и файлов в Linux используется только прямой слеш.</li>
<li>В Linux принята стандартная структура файлов.</li>
</ol>
</div>
<h3 id="что-такое-относительные-и-абсолютные-пути">Что такое относительные и абсолютные пути?</h3>
<p>Для того, чтобы операционная система, программы и пользователи могли работать с файлами и обращаться к ним у каждого файла должен быть уникальный идентификатор. Но просто имени недостаточно, потому что могут существовать несколько файлов с одинаковыми именами. Поэтому операционная система обращается к файлам используя пути.</p>
<p>Путь к файлу можно задавать двумя способами - абсолютным или относительным. Абсолютный путь начинается с символа / и отсчитывается от корневого каталога. Относительный путь начинается с имени папки и отсчитывается от текущего каталога. Это сделано для удобства указания пути, чтобы не повторять одно и то же, если вы работаете в данный момент преимущественно с файлами в одной папке.</p>
<p>При указании путей к файлам можно пользоваться некоторыми сокращениями. Вы можете использовать два специальных имени: точку (.), означающую текущую директорию, и пару точек (..), означающую родительскую директорию текущей директории. Также вы можете использовать символ тильды (~), который означает вашу домашнюю директорию, и сочетание ~username, означающее домашнюю директорию пользователя с именем username.</p>
<p>Помните, что нужно четко представлять себе, где лежит тот или иной файл для того, чтобы с ним работать. Часто /etc/passwd и etc/passwd - это два совершенно разных файла в разных местах. Поэтому нужно всегда четко представлять себе расположение нужного вам файла относительно текущей директории и использовать относительные или абсолютные пути правильно, не путая их.</p>
<p>Может показаться, что для простоты и надежности следует всегда использовать абсолютные пути. Однако относительный формат был придуман не просто так. С одной стороны, он добавляет удобства и скорости работы в командной строке, так как абсолютные пути могут быть очень длинными и в них легко ошибиться ил опечататься. Именно для этого придумано понятие текущей папки - это просто название папки, которое автоматически поставляется в относительные пути, чтобы получить абсолютный.</p>
<p>Но у относительных путей есть и еще одно применение. Представьте, что вы пишите скрипт или программу, которая работает с файлами в какой-то своей папке. У рабочей папки программы может быть разное расположение на разных компьютерах, или оно может поменяться если вы просто перенесете программу в другое место. Если вы используете абсолютные пути, то при каждом таком переносе программа просто сломается. То есть абсолютные пути слишком зависят от положения точки отсчета и делают программу непереносимой. Использование же относительных путей решает эту проблему - при переносе программы в другое место вся внутренняя структура папок сохранится и программа будет работать корректно без необходимости менять исходный код.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>У каждого файла в системе есть один уникальный адрес.</li>
<li>Следует различать абсолютные и относительные пути к файлам.</li>
<li>Абсолютный путь отсчитывается от корня файловой системы и не зависит от того, где находится пользователь.</li>
<li>Относительный путь отсчитывается от текущей директории пользователя.</li>
<li>Смысл переходить по директориям как раз в том, чтобы относительные пути были короче.</li>
<li>Лучше использовать относительные пути в программах и скриптах для переносимости.</li>
</ol>
</div>
<h3 id="какие-виды-файлов-существуют">Какие виды файлов существуют?</h3>
<p><img alt="styled-image" class="align-center" src="/assets/images/os_text/lx13-2.png" style="width: 800px;" title="Linux file types"/></p>
<p>Мы уже говорили раньше, что UNIX-подобные операционные системы представляют многие разные объекты, с которыми приходится работать в виде файлов. Это удобно и для операционной системы и для пользователей. Давайте кратко перечислим основные виды файлов и их зачем они нужны. Посмотреть тип файла всегда можно командой ls -l. В строке соответствующей файлу самый первый символ, один из атрибутов файла, указывает его тип.</p>
<p>Обратите внимание, что тип файла - это не расширение, как в Windows. Там расширение является обязательным элементом имени файла и показывает операционной системе, какой программой его нужно “открывать”, то есть обрабатывать его содержимое. Другими словами, расширение файла характеризует характер содержимого этого файла. В UNIX принята другая система. Изначально вы запускаете программы командами в терминале, то есть явно указываете название программы, которая должна запуститься и обрабатывать тот или иной файл. Поэтому расширение для операционной системы необязательно. Но с распространением графических интерфейсов, когда пользователи привыкают открывать файл щелчком мыши, практика использования расширений в именах файлов начинает распространяться и на Linux. Так почти все графические окружения поддерживают ассоциации файлов с программами через расширения, как в Windows. Кроме того, это удобно пользователю, так как глядя на имя файла он может предположить, что за информация там хранится.</p>
<p>Самый простой тип файла так и называется - обычный файл. Он помечается символом дефиса (-). Это именованная область данных на носителе, которая может содержать произвольную информацию. Часто чтобы не путаться этот тип файлов называется документом, хотя в Linux к обычным файлам относятся и мультимедийные, и офисные, и исполняемые файлы программ и файлы с исходным текстом программ и скриптов. Короче говоря, все, что в Windows называется файлом, в Linux - обычный файл.</p>
<p>Мы уже говорили, что папки в UNIX - это тоже файлы. Это второй по распространенности тип файлов - папки, директории или каталоги. Это все разные названия одного и того же. Они служат для организации файлов и упрощения навигации по файловой системе. В Linux папки - это по сути просто специальный файл, который содержит список других файлов, которые считаются “лежащими” в этой папке. Файл типа каталога помещается символом d.</p>
<p>Еще один тип файлов - это ссылки. Они помечаются символом l (link). Ссылки вместо пользовательских данных содержат путь к другому файлу. Именно этот файл будет открываться при обращении к ссылке. Этот механизм работает аналогично ярлыкам в Windows. Ссылки нужны для более удобной организации файлов, иногда бывает полезно иметь доступ к одному и тому же файлу из разных мест, то есть папок. Можно, конечно, файл просто скопировать, но копирование файлов расходует место на диске и при изменении одной копии вторая останется старой. Надо понимать, что при удалении или перемещении исходного файла все ссылки на него, если такие есть, перестанут работать. Такие ссылки называются битыми.</p>
<p>Надо сказать, что все это относится к так называемым символическим, или мягким ссылкам. Именно они работают подобно ярлыкам. Но в Linux есть и другой тип ссылок - жесткие ссылки. Жесткие ссылки работают совершенно по-другому и на другом уровне. По сути дела - это просто другое имя одного и того же файла. Любой файл имеет как минимум одну жесткую ссылку на него - это само имя файла. Но вы можете создать новую ссылку. И для операционной системы все жесткие ссылки на файл являются равноправными, в отличие от символических, где есть сам файл и ссылки на него. Даже если вы удалите файл по первоначальному имени, если на него есть еще жесткие ссылки, он проложит существовать. Файл удаляется тогда, когда перестает существовать последняя жесткая ссылка на него.</p>
<p>Еще один тип файлов в UNIX - это специальные файлы устройств. Их можно распознать по символу c или b в атрибутах.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Обычные файлы содержат информацию в виде данных или программного кода.</li>
<li>В Linux тип файла - это не расширение, они вообще не обязательны.</li>
<li>Директории, каталоги или папки - это список файлов.</li>
<li>Ссылки используются для удобства нахождения файла в нескольких папках одновременно.</li>
<li>Символические ссылки - это как ярлыки в Windows.</li>
<li>Жесткие ссылки - это два адреса одного и того же файла.</li>
<li>Сокеты используются для взаимодействия между процессами.</li>
</ol>
</div>
<h3 id="как-работать-со-ссылками-в-консоли">Как работать со ссылками в консоли?</h3>
<p>Самые распространенные операции с обычными файлами и каталогами мы уже изучали ранее. Сейчас поговорим о более специфичном для Linux явлении - ссылках. Для того, чтобы поглубже понять, как работают ссылки, нам надо сначала разобраться, что такое inode.</p>
<p>inode – это объект файловой системы, содержащий информацию о владельце/группе, которым принадлежит файл или каталог, его права доступа к нему, его размер, тип файла, timestamp-ы отражающие время модификации индексного дескриптора (ctime, changing time), время модификации содержимого файла (mtime, modification time) и время последнего доступа к файлу (atime, access time) и счётчик для учёта количества жёстких ссылок на файл. Каждый inode имеет собственный номер, который присваивается ему файловой системой в момент её создания (форматирования). По сути, inode - это уникальный численный идентификатор файла в файловой системе. Узнать inode обычному пользователю не требуется, но если интересно, можно воспользоваться опцией -i команды ls:</p>
<p><img alt="Inodes" class="align-center" src="/assets/images/os_text/lx13-3.png" style="width: 800px;" title="Inodes"/></p>
<p>Иногда может возникнуть “странная” ситуация: с одной стороны – df или du будут говорить, что свободное место на диске есть, а с другой стороны операционная система будет утверждать, что “No Space Left on Device”. Одна из вероятных причин как раз явлется полное использование пула inode, выделенных для раздела на жёстком диске, т.к. кол-во inode фиксировано и задаётся во время создания таблицы раздела. Проверить общее, занятое и доступное количество inode можно с помощью df и опции -i:</p>
<p><img alt="Inode availability" class="align-center" src="/assets/images/os_text/lx13-4.png" style="width: 800px;" title="Inode availability"/></p>
<p>Создать жесткую ссылку на файл можно командой ln. синтаксис команду такой:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ln </span>целевой_файл файл_ссылка
</pre></td></tr></tbody></table></code></pre></div></div>
<p>при этом можно создать ссылку как на файл из этой же папки, так и на любой другой. Для этого надо воспользоваться относительными или абсолютными путями к файлу.</p>
<p><img alt="Hard link creation" class="align-center" src="/assets/images/os_text/lx13-5.png" style="width: 800px;" title="Hard link creation"/></p>
<p>Кстати, вы не можете создать жесткую ссылку на файл, к которому у вас нет доступа на запись, ведь формально вы вносите изменение в inode. А для этого вы должны обладать соответствующими правами.</p>
<p>Обратите внимание, что у исходного файла и у ссылки - один и тот же inode. То есть по сути для операционной системы это один и тот же файл с двумя разными именами. Кстати, даже изначальный файл строго говоря - это жесткая ссылка на свой собственный  inode. Поэтому жесткая ссылка - это не как ярлык к файлу, это именно два разных имени одного и того же файла.</p>
<p><img alt="Hard link deletion" class="align-center" src="/assets/images/os_text/lx13-6.png" style="width: 800px;" title="Hard link deletion"/></p>
<p>Поэтому при удалении исходного файла жесткая ссылка на него никуда не девается и даже продолжает работать. Сам файл, то есть inode, удалится только тогда, когда на него будет удалена последняя жесткая ссылка. Именно для этого у каждого файла отслеживается количество жестких ссылок на него. Это число вы можете видеть в подробном выводе команды ls после прав доступа и перед ником владельца файла.</p>
<p><img alt="Symlink" class="align-center" src="/assets/images/os_text/lx13-7.png" style="width: 800px;" title="Symlink"/></p>
<p>А вот символические ссылки, symlink’и, работают именно как ярлыки Windows, то есть как указатели на файл. Создать символическую ссылку можно командой</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ln</span> <span class="nt">-s</span> целевой_файл файл_ссылка
</pre></td></tr></tbody></table></code></pre></div></div>
<p>В терминале символические ссылки отображаются по -другому. Во-первых, обратите внимание на тип файла. Это уже символ ‘l’ - то есть ссылка. Во-вторых, inode изначального файла и ссылки отличаются. И в-третьих после имени ссылки указывается имя файла, на который она ссылается. Причем, если удалить исходный файл, ссылка перестанет работать. Она станет так называемой “битой ссылкой”, то есть ссылкой, которая никуда не ведет. В терминале с цветовой подсветкой такие ссылки дополнительно отображаются красным цветом для привлечения внимания.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Создание, удаление, копирование, перемещение файлов изучалось ранее.</li>
<li>inode - это уникальный численный идентификатор файла в файловой системе.</li>
<li>inodes могут закончиться на разделе жесткого диска, тогда вы не сможете создать файл, даже если места для него хватает.</li>
<li>Создать жесткую ссылку на файл можно командой ln.</li>
<li>Файл существует до тех пор, пока на него есть хотя бы одна жесткая ссылка.</li>
<li>Создать символическую ссылку на файл можно командой ln -s.</li>
<li>Если удалить символическую ссылку исходный файл останется нетронутым.</li>
<li>Если удалить сам файл, то все символические ссылки на него станут недействующими.</li>
</ol>
</div>
<h3 id="что-такое-перенаправление-ввода-вывода">Что такое перенаправление ввода-вывода?</h3>
<p>Как мы уже говорили, все консольные команды Linux являются текстоцентричными - они принимают на вход текстовый поток и выдают в качестве результата тоже какой-то текстовый поток. Текстовый поток - это по сути, одна или несколько строк текстовой информации, которая читается последовательно. Текстовые потоки очень похожи на текстовые файлы - у них есть начало, определенный конец. Но в отличие от файлов потоки читаются только последовательно, символ за символом, пока не будет достигнут специальный символ, обозначающий конец потока.</p>
<p>У любого процесса в операционной системе Linux существует три стандартных текстовых потока, ассоциированных с ним. Они создаются и связываются в процессом самой операционной системой. Поэтому они называются стандартными потоками. Это все справедливо, в частности, для всех команд терминала.</p>
<p>Стандартный поток ввода (STDIN) при работе пользователя в терминале связывается с клавиатурой. При работе команды она может считать текст их с STDIN. в таком случае выполнение команды приостанавливается и она ждет ввода пользователем текста в терминале, в котором выполняется команда. Когда пользователь введет текст и нажмет <enter>, либо <ctrl>+<d> (окончание текстового потока), введенный текст передается в команду.</d></ctrl></enter></p>
<p>Стандартный поток вывода (STDOUT) предназначен для отображения результата работы программы. Он по умолчанию связывается с терминалом, в котором она выполняется. Если программа посылает какой-то текст на свой STDOUT (в Python для этого существует оператор print, в bash - его аналог echo), пользователь видит его в терминале.</p>
<p>Стандартный поток ошибок (STDERR) работает аналогично STDOUT, но предназначен для вывода сообщений об ошибках, возникающих в процессе работы программы. По умолчанию он так же выводится в терминал, но по желанию программы или пользователя его можно перенаправить отдельно от обычного стандартного потока вывода.</p>
<p>В процессе своей работы команда или программа может открывать дополнительные потоки, например, открыв сетевое соединение или файл на чтение или запись. Но три стандартных потока существуют всегда. Большинство стандартных программ и команд Linux устроены таким образом, что все необходимые для своей работы данные они должны считывать с STDIN, на все результаты совей работы записывать в STDOUT. Таким образом программа представляет собой такой черный ящик в одним входом и одним выходом. Это очень полезное и распространенное соглашение по проектированию текстовых программ Linux, которое позволяет их объединять.</p>
<p>Потоки ввода-вывода можно перенаправлять и подключать к чему угодно: к файлам, программам или даже устройствам. Эта возможность очень мощная и полезная в определенных условиях. При помощи перенаправления потоков можно использовать программы и команды Linux гораздо более удобным и коротким образом. Перенаправления ввода-вывода осуществляются при помощи специальных обозначений, которые обычно указываются после команды, ввод или вывод которой вы хотите перенаправить. Существует несколько вариантов такого перенаправления:</p>
<ul>
<li>&lt; file — использовать файл как источник данных для стандартного потока ввода.</li>
<li>&gt; file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.</li>
<li>2&gt; file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.</li>
<li>&gt;&gt;file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.</li>
<li>2&gt;&gt;file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.</li>
<li>&amp;&gt;file или &gt;&amp;file — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: &gt;file 2&gt;&amp;1.</li>
</ul>
<p>Давайте рассмотрим наиболее распространенные сценарии такого перенаправления.</p>
<p>Возьмем для примера программу cat. Она считывает один ил несколько файлов, переданных ей как аргументы и выводит их содержимое (если файлов несколько, то она “склеит”, конкатенирует их содержимое, отсюда и название команды) на свой STDOUT. При помощи символа &gt; после команды можно перенаправить ее STDOUT в другое место, например, в файл. Таким образом, если выполнить команду:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat </span>file1 file1 file1 <span class="o">&gt;</span> bigfile
</pre></td></tr></tbody></table></code></pre></div></div>
<p>то вместо вывода содержимого файлов на экран, в терминал, команда cat запишет этот текстовый поток в файл bigfile. То есть эта команда объединит содержимое нескольких файлов в один. Таким же способом можно записать в файл результат работы любой команды.</p>
<p>Обратите внимание, что при использовании символа &gt; если целевой файл уже существует, то он будет перезаписан. Если вам нужно добавить информацию в существующий файл, то следует использовать оператор &gt;&gt;. Он имеет такой же эффект, но всегда добавляет новый текстовый поток в конец файла. Если же файла нет, то эти два оператора работают идентично.</p>
<p>Аналогично работает и перенаправление из файла. Например, существует команда sort, которая сортирует строки из текстового потока по алфавиту. По умолчанию, эта команда принимает текст для сортировки из своего STDIN, но в нее можно направить файл вот так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sort</span> &lt;domains.list
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Такая команда выведет в терминал отсортированный файл. Текстовый команды Linux именно поэтому и работают со стандартными потоками. Хотя в первого взгляда это может показаться нелогичным и неудобным, их можно перенаправлять как угодно и за счет этого модифицировать действие команд.</p>
<p>В качестве файлов при перенаправлении можно использовать и устройства. Например, в Linux существует специальное псевдоустройство /dev/null. Все, что попадает в него никуда не идет, не отображается и не сохраняется. Эта такая информационная “черная дыра”. Казалось бы, зачем? Но такое устройство может пригодиться, если нам нужно “подавить” вывод какой-то команды, то есть не отображать его на экране, не записывать в файл, просто игнорировать:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>apt <span class="nb">install</span> <span class="nt">-y</span> tmux <span class="o">&gt;</span> /dev/null
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Надо сказать, что операторы &gt;, &gt;&gt; и &lt; работают только, когда с одной стороны команда, а с другой - файл (или псеводустройство). но можно и объединять команды - то есть перенаправлять вывод одной команды на ввод другой. Такая операция называется конвейером (pipe) и обозначается оператором |. Например, таким образом какой-то очень длинный вывод можно подать на вход программе-пейджеру, которая отобразит его с возможностью перелистывания:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> | less
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Операции перенаправления и/или конвейеры могут комбинироваться в одной командной строке.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">command</span> &lt;input-file <span class="o">&gt;</span>output-file
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>command1 | command2 | command3 <span class="o">&gt;</span>output-file
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Линуксовые команды работают с текстовым вводом и текстовым выводом.</li>
<li>У каждого процесса есть три стандартных текстовых потока - ввод, вывод и поток ошибок.</li>
<li>Можно перенаправить результат команды в файл при помощи &gt; или &gt;&gt;.</li>
<li>Можно направить содержимое файла на вход команде при помощи &lt;.</li>
<li>Объединять команды можно при помощи конвейера |.</li>
</ol>
</div>
<h3 id="как-работать-с-архивами">Как работать с архивами?</h3>
<p>При работе с файлами и папками часто возникает задача работы с архивами. Архив - это файл, который содержит в сжатом виде несколько файлов или папок. Архивы - это удобный способ хранения и обмена информацией. Существует большое количество алгоритмов архивации данных, множество программ-архиваторов и, соответственно, множество форматов архивных файлов. Пользователи Windows, больше всего знакомы с архивами .zip или .rar.</p>
<p>В Linux тоже существуют много программ-архиваторов, но самыми распространенными являются zip, tar и gzip. Самая простая и понятная программа, которую мы советуем новичкам - это zip. Она имеется в большинстве пользовательских дистрибутивов, проста по синтаксису, работает с самым распространенным форматом архивов.</p>
<p>Команда</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>zip archive.zip file1
</pre></td></tr></tbody></table></code></pre></div></div>
<p>сжимает файл в архив. При помощи команды zip archive.zip * можно сжать в архив всю папку.</p>
<p>Разархивация такого архива осуществляется командой unzip:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>unzip archive.zip 
</pre></td></tr></tbody></table></code></pre></div></div>
<p>С помощью опции -d можно указать другую папку, куда будет распаковано содержимое архива. Кроме того, вторым аргументом можно указать конкретный файл, который должен быть извлечен из архива.</p>
<p>Кроме формата zip, пользователи Linux могут встретиться с архивами формата .tar. Обычно они имеют двойной расширение - .tar.gz или .tar.bzip2. Это архивы, созданные программой tar - классической командой Linux. Особенностью этой программы является то, что она умеет создавать и распаковывать архивы, но не умеет их сжимать. Поэтому для сжатия используются другие инструменты - программы zip, gzip или bzip2.</p>
<p>Если вы встретили такой архив, то его можно распаковать командой:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">tar</span> <span class="nt">-xvf</span> file.tar.gz
</pre></td></tr></tbody></table></code></pre></div></div>
<p>У этой команды почти всегда много опций. x означает распаковку архива, v - вывод подробной информации о процессе (необязательно), f - указание файла для распаковки.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Команда zip archive.zip file1 сжимает файл в архив.</li>
<li>Команда zip archive.zip * сжимает в архив все файлы из текущей директории.</li>
<li>Команда zip -r archive.zip directory1 directory2 directory3 позволяет сделать архив из папок.</li>
<li>Команда unzip -l file.zip показывает содержимое архива.</li>
<li>Команда unzip file1.zip распаковывает архив.</li>
<li>Команда unzip file1.zip -d folder/ распаковывает архив в определенную папку.</li>
<li>Команда unzip file1.zip file извлекает файл из архива.</li>
<li>Команда tar -xvf archive.tar распаковывает архив в текущую директорию.</li>
</ol>
</div>
<h3 id="как-найти-нужный-файл">Как найти нужный файл?</h3>
<p>При работе в командной строке очень часто возникает задача найти файл или информацию. Специально для этого существует очень мощная команда find - одна из самых часто используемых команд терминала. find - это стандартная команда, ее не надо устанавливать отдельно, она присутствует во всех дистрибутивах Linux.</p>
<p>Общий синтаксис команды find выглядит так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>find <span class="o">[</span>папка] <span class="o">[</span>критерий] <span class="o">[</span>действие]
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Первым параметром всегда идет папка, в которой будет производиться поиск. Если ее не указать, то команда будет искать файлы в текущей папке.</p>
<p>С помощью критериев можно задать особые условия поиска. Так, критерий -name осуществляет поиск по имени файла. Причем в имени можно задать шаблон. Например, такая команда будет искать все файлы с расширением txt:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>find <span class="nb">.</span> <span class="nt">-name</span><span class="s2">"*.txt"</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Критерий -type позволяет искать файлы по типу, которые бывают следующих видов:</p>
<ul>
<li>f – простые файлы;</li>
<li>d – каталоги;</li>
<li>l – символические ссылки;</li>
<li>b – блочные устройства (dev);</li>
<li>c – символьные устройства (dev);</li>
<li>p – именованные каналы;</li>
<li>s – сокеты;</li>
</ul>
<p>Например, указав критерий -type d будут перечислены только каталоги.</p>
<p>Довольно полезен критерий size, который задает размер файла. Можно искать файлы больше или меньше указанного размера с помощью символов + или -, либо по точному размеру, например так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>find <span class="nb">.</span> size +1G
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Кроме того, другие критерии этой команды позволяют искать файлы по владельцу, по времени модификации, времени доступа, задавать глубину поиска по подкаталогам, игнорировать регистр, и еще много чего. Для полного знакомства с этой командой рекомендуется прочитать мануал по ней для вашего дистрибутива.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Для поиска файлов в Linux удобнее всего использовать команду find.</li>
<li>Пример использования: find /home/ -size +1000000k</li>
</ol>
</div>
<h3 id="как-сделать-резервную-копию">Как сделать резервную копию?</h3>
<p>Одна из самых типичных задач администратора операционной системы - резервное копирование информации (бекап). Оно позволяет застраховаться на случай аппаратных или программных сбоев, ведь именно информация - это самое ценное, что существует в компьютерных системах. Но вообще, резервным копированием нужно заниматься и обычным пользователям, ведь у вас тоже может быть важная информация, которую не хотелось бы потерять. Особенно важно производить бекапы в условиях изменений информационной среды - обновлении программ и операционной системы, миграции на новые версии программ, в ходе разработки программного обеспечения, при развертывании рабочих и тестовых сред.</p>
<p>Rsync (Remote Sync) — это наиболее часто используемая команда для удаленного и локального копирования и синхронизации файлов и каталогов в системах Linux/Unix. С помощью команды rsync вы можете удаленно и локально копировать и синхронизировать данные между каталогами, дисками и сетевыми хранилищами, выполнять резервное копирование данных.</p>
<p>Программа rsync не всегда поставляется вместе с дистрибутивом, поэтому проверьте, есть ли она у вас. Если у вас команда rsync выдает сообщение о том, что программа не найдена, то вам надо установить ее командой:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>rsync
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Базовый синтаксис программы rsync выглядит так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>rsync options <span class="nb">source </span>destination
</pre></td></tr></tbody></table></code></pre></div></div>
<p>source и destination - это названия файлов или папок, соответственно, откуда и куда будет произведено копирование. Обычно происходит копирование из какой-то папки в папку или файл на другом разделе жесткого диска, даже на другой машине, по сети.</p>
<p>Как у любой мощной команды, у rsync большое количество опций. Перечисли самые полезные:</p>
<ul>
<li>-v: подробный вывод.</li>
<li>-r: рекурсивно копирует данные (но не сохраняет временные метки и разрешения при передаче данных).</li>
<li>-a: режим архива, позволяет рекурсивно копировать файлы, а также сохраняет символические ссылки, права доступа к файлам, права владения пользователей и групп и временные метки.</li>
<li>-z: сжатие данных в ходе копирования.</li>
<li>-h: вывод информации о ходе копирования</li>
</ul>
<p>Основной особенностью команды rsync по сравнению с обычным копированием является то, что она копирует данные инкрементально. То есть, если в месте назначения уже была более старая резервная копия, то rsync будет копировать только разницу, то есть то, что изменилось с последнего бекапа. Это позволяет сильно экономить на времени и ширине канала копирования, особенно, если вы делаете бекапы часто.</p>
<p>Кроме локального копирования, rsync позволяет так же просто делать бекапы по сети с или на удаленный хост. Для этого, он должен быть доступен по сети, мы должны знать его адрес (обычно, IP-адрес или доменное имя), а так же иметь учетные данные (то есть знать имя пользователя и его пароль на удаленной машине). Указать удаленную машину можно, например, так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>rsync <span class="nt">-avz</span> rpmpkgs/ root@192.168.0.100:/home/
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Перед началом копирования команда попросит вас ввести пароль. Подключение может проходить по протоколу защищенного соединения SSH, тогда данные еще и шифруются при передаче.</p>
<p>Rsync, как и многие сетевые программы является клиент-серверной программой. Это значит, что для успешного общения двух машин по протоколу rsync необходимо, чтобы эта программа была установлена на обоих машинах. Более того, на удаленном компьютере должен быть настроен сервер rsync, то есть разрешены сетевые подключения к этой программе.</p>
<p>Для этого нужно создать файл настроек /etc/rsyncd.conf (создание файлов в системной папке /etc/ доступно только пользователю root) с примерно таким содержанием:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsync.log
[share]
path = /tmp/share/
hosts allow = 192.168.56.1
hosts deny = *
list = true
uid = root
gid = root
read only = false
</pre></td></tr></tbody></table></code></pre></div></div>
<p>В этом файле мы для безопасности разрешаем удаленный доступ к данному компьютеру через rsync только с одного IP-адреса - 192.168.56.1. Вам, конечно, нужно прописать адрес той машины, с которой вы будете запускать бекапы.</p>
<p>После создания конфигурационного файла необходимо запустит сервер и добавить его в автозагрузку.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>systemctl start rsync
<span class="nv">$ </span><span class="nb">sudo </span>systemctl <span class="nb">enable </span>rsync
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Если эти две команды выполнились без ошибок, это значит, что можно пользоваться службой rsync для удаленного резервного копирования.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Программа Rsync используется для инкрементального резервного копирования.</li>
<li>Команда rsync -avr /source/ /destination/ копирует содержимое одной папки в другую.</li>
<li>Rsync позволяет копировать с или на удаленный хост используя протокол SSH.</li>
<li>Синхронизация с удаленным хостом выполняется командой rsync -avz /tmp/ root@192.168.56.102:/home/</li>
<li>Для работы с удаленным сервером там должен быть установлен и настроен сервер rsync.</li>
</ol>
</div>
</div>
<header class="caption">
<h1>Управление файлами в Linux</h1>
<!-- <p>Yours Truly, Famous Inc.</p> -->
</header>
<section class="slide">
<h2 class="shout">Управление файлами в Linux</h2>
</section>
<footer class="badge">
<a href="https://github.com/shower/shower">Build with shower</a>
</footer>
<script src="/assets/shower/shower.js"></script>
<!-- Copyright © 3000 Yours Truly, Famous Inc. -->
<script type="text/javascript">
        
        const content = document.querySelector('#temp');
        const childern = content.childNodes;

        let current_slide;
        let points;
        let code;
        let image;
        let misc;

        function commit() {
            if (current_slide) {

                const elems = [image, code, points, misc];

                let slide;

                elems.forEach(elem => {
                    if (elem) {
                        // console.log("ИТЕРАЦИЯ " + current_slide);
                        // console.log([image, code, points, misc]);

                        slide = document.createElement('section');
                        slide.className = "slide";
                        let slide_header = document.createElement('h2');
                        slide_header.innerHTML = current_slide;
                        slide.appendChild(slide_header);

                        slide.appendChild(elem);

                        document.body.appendChild(slide);

                        fit_in_slide(elem);
                    }
                });

                misc = undefined;
                points = undefined;
                image = undefined;
                code = undefined;
            }
        }

        function fit_in_slide(element) {
            console.log("ИТЕРАЦИЯ " + current_slide);
            console.log(element);

            let ratio = Math.min(
            	550 / element.offsetHeight,
            	// 1600 / element.offsetWidth,
            	);


            let new_size = Math.sqrt(ratio) / 1.2;
            if (new_size > 2.5) {
                new_size = 2.5
            }
            element.style["font-size"] = new_size + "em";

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            ratio = Math.min(
            	550 / element.offsetHeight,
            	1600 / element.offsetWidth,
            	);

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            console.log(element.innerHTML);            
            console.log(element.querySelectorAll("*"));            
            console.log(element.querySelectorAll("pre"));

            element.querySelectorAll("pre").forEach(e => {
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            element.querySelectorAll("span").forEach(e => {
            	console.log("found");
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            console.log(
                // realHeight, ratio, 
                new_size, 
                element.offsetHeight,
                element.offsetWidth);

            return element;
        }

        childern.forEach(elem => {
            if (elem.tagName == "H3") {
                commit();
                let slide = document.createElement('section');
                slide.className = "slide";
                let slide_header = document.createElement('h2');
                slide_header.className = "shout shrink"
                slide_header.innerHTML = elem.innerHTML;
                slide.appendChild(slide_header);

                // slide.appendChild(elem);

                document.body.appendChild(slide);
            }

            if (elem.tagName == "H3" || elem.tagName == "H4") {
                commit();
                current_slide = elem.innerHTML;
            }

            else if (elem.tagName == "DIV" && elem.classList.contains("notice--info")) {
                let list = elem.getElementsByTagName('ol')[0];

                list.childNodes.forEach(elem => {
                    elem.className = "next";
                });

                points = list;
                // points = fit_in_slide(points);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("highlighter-rouge")) {
                code = elem;
                commit()
                // code = fit_in_slide(code);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("presentation")) {
                misc = elem;
                // misc = fit_in_slide(misc);
                commit();
            } 

            else if (elem.tagName == "P" && elem.getElementsByTagName('img').length > 0) {
                image = elem.getElementsByTagName('img')[0];
                image.style.width = "auto";
                commit();
            } 
        });

        commit();

        content.remove();

    </script>
<div class="progress"></div>
<script src="/assets/js/main.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1K09X3NDBE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1K09X3NDBE', { 'anonymize_ip': false});
</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(77706580, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img alt="" src="https://mc.yandex.ru/watch/77706580" style="position:absolute; left:-9999px;"/></div></noscript>
<!-- /Yandex.Metrika counter -->
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</body>
</html>
