<!DOCTYPE html>
<html lang="en">
<head>
<title>Использование удаленного доступа по SSH</title>
<meta charset="utf-8"/>
<link href="/assets/css/main.css" rel="stylesheet"/>
<meta content="width=device-width, initial-scale=1, viewport-fit=cover" name="viewport"/>
<link href="/assets/shower/themes/ribbon/styles/styles.css" rel="stylesheet"/>
<style>
        .shower {
            --slide-ratio: calc(16 / 12);
        }
    </style>
<style>

        html{
            background-color: #000;
        }

        body{
            min-height: 0;
            background-color: #000;
        }

        #cover h2 {
            margin: 30px 0 0;
            /*color: white;*/
            text-align: center;
            font-size: 70px;
        }

        #cover p {
            margin: 10px 0 0;
            text-align: center;
            color: white;
            font-style: italic;
            font-size: 12px;
        }

        #cover p a {
            /*color: white;*/
        }

        #temp {
            display: none;
            visibility: hidden;
        }

        section {
            font-size: 20px;
        }

        section h2 {
            font-size: 50px;
        }

        .slide{
            line-height: 1.2em;
            font-size: 1em;
        }

        .slide ol, .slide ul {
            line-height: 1em;
        }

        .slide pre {
            overflow-x: hidden; 
            overflow-y: hidden; 
            line-height: 1.2em;
            /*font-size: 1em;*/
        }

        img {
            max-height: 550px;
            width: auto;
        }

        img#cover{
            height: 100%;
            width: auto;
        }

        .slide .shout {
            font-size: 120px;
        }

        .mjx-chtml{
        	font-size: 25px !important;
        }

        section > div.presentation, section > img{
		  margin: 0;
		  position: absolute;
		  top: 460px;
		  left: 50%;
		  -ms-transform: translate(-50%, -50%);
		  transform: translate(-50%, -50%);
		}
    </style>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
	   MathJax.Hub.Config({
	     extensions: ["tex2jax.js"],
	     jax: ["input/TeX", "output/HTML-CSS"],
	     tex2jax: {
	       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	       processEscapes: true
	     },
	     "HTML-CSS": { availableFonts: ["TeX"] }
	   });
	</script>
</head>
<body class="shower list">
<div id="temp">
<h3 id="зачем-нужен-протокол-ssh">Зачем нужен протокол SSH?</h3>
<p>Обычные пользователи почти всегда работают с компьютером локально. То есть они физически находятся у компьютера, используют имеющиеся у него устройства ввода-вывода (клавиатуру, мышь, дисплей) для выполнения необходимых операций. Однако, не всегда есть возможность физически находиться у компьютера, с которым нужно работать. Например, если вы хотите создать свой сайт, то он будет размещен на компьютере хостинг-провайдера. Этот компьютер может находиться на другом конце света. Вам нужен способ запускать команды на этом компьютере не выходя из своего дома. При профессиональной работе с компьютерами часто возникает потребность выполнять определенные операции на удаленных машинах. Например, системный администратор может обслуживать компьютерную сеть, состоящую из десятков компьютеров. Было бы очень неудобно постоянно физически перемещаться между компьютерами. Более того, удаленный компьютер может располагаться, например, в центре обработки данных у облачного провайдера, или быть вообще виртуальной машиной на кластере. Такое часто бывает при использовании облачных систем.</p>
<p style="text-align: center; font-size:0.7em;"><img alt="Datacenter" class="align-center" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTNBrnhYAgro1NXSkPZoJ_Z5fygfHCAD0MQfQ&amp;usqp=CAU" style="width: 800px;" title="Datacenter"/>
Источник: <a href="https://securityboulevard.com/">securityboulevard.com</a>.</p>
<p>Специально для таких случаев существуют протоколы удаленного доступа. Они позволяют подключиться к удаленному компьютеру и работать на нем так же, как вы обычно работаете на локальной физической машине. Такие протоколы разделяются на графические и текстовые. Графические протоколы, например, RDP (remote desktop protocol) передают по сети изображение графического интерфейса в одну сторону, движения мыши и события клавиатуры - в другую. Текстовые протоколы, такие как Telnet или SSH, передают только текстовую информацию и позволяют работать в терминале удаленной машины. Здесь мы рассмотрим самый популярный текстовый протокол удаленного доступа - SSH.</p>
<p>SSH — защищенный протокол для удаленного доступа к компьютерам. Через SSH можно выполнять операции в командной строке компьютера, который физически находится в другом месте. Иными словами, SSH — это дистанционная командная строка. Визуально вы работаете на своем компьютере, но в реальности — на другом.</p>
<p>Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. SSH — это набор правил, который известен и вашему компьютеру, и физически отдаленному компьютеру. Пример: вы вводите команду удаления файла, и эта команда передается на другой компьютер и выполняется там. Ответ (или сообщение об ошибке) возвращается и показывается на вашем компьютере.</p>
<p>При удаленной работе обычно используются существующие открытые каналы коммуникации, то есть компьютерные сети. Почти всегда - подключение происходит через Интернет. Поэтому очень важно обеспечить безопасность соединения. При использовании протокола SSH вся информация передается в зашифрованном виде. Подобно тому, как некоторые сайты работают по HTTPS, шифруя информацию. Например, ваш онлайн-банкинг обязательно должен работать по защищенному соединению. В таком случае даже если всю информацию перехватывает злоумышленник, он не сможет расшифровать её.</p>
<p>Используя SSH можно подключиться к любой удаленной машине при соблюдении некоторых условий. Ни параметры удаленной машины, ни расстояние не имеют значения. Также можно подключаться как к физическим, так и к виртуальным машинам. При подключении, вы даже можете не знать, к чему вы подключаетесь, к физическому компьютеру или к виртуальной машине в датацентре какой-то компании. При работе никакой разницы вы не заметите.</p>
<p>Как и большинство сетевых протоколов, SSH работает по клиент-серверному принципу. То есть на вашем компьютере, за которым вы работаете физически должна быть установлена специальная программа - ssh клиент. С ее помощью вы и будете подключаться к другим машинам. А на удаленной машине, то есть той, к которой вы подключаетесь должна работать другая программа - ssh сервер. Она будет принимать ваше подключение, выполнять ваши команды, следить за правами доступа и так далее. Как настроить и клиент и сервер мы поговорим далее.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>При работе часто возникает потребность выполнять операции на разных удаленных хостах.</li>
<li>Обычное незащищенное соединение для этого не подходит из-за проблем с безопасностью.</li>
<li>Протокол SSH позволяет выполнять команды терминала на удаленной машине.</li>
<li>Протокол SSH начинает шифровать соединение еще до ввода пароля пользователя.</li>
<li>Таким образом можно подключаться к любым машинам, физическим и виртуальным.</li>
<li>SSH является клиент-серверным протоколом. На локальной машине работает клиент ssh, на удаленной - сервер.</li>
</ol>
</div>
<h3 id="что-нужно-для-успешного-удаленного-доступа">Что нужно для успешного удаленного доступа?</h3>
<p style="text-align: center; font-size:0.7em;"><img alt="SSH client and server" class="align-center" src="https://upload.wikimedia.org/wikipedia/commons/c/c8/SSH_diagram.png" style="width: 800px;" title="SSH client and server"/>
Источник: <a href="https://commons.wikimedia.org/wiki/File:SSH_diagram.png">Wikimedia</a>.</p>
<p>Для того, чтобы иметь возможность подключиться к удаленной машине нужно соблюдение нескольких условий. Во-первых, как мы уже говорили, на ней должен быть установлен и работать ssh сервер. Существуют разные сервера, но самым распространенным является свободный и бесплатный сервер openssh. Он существует и для Linux и для Windows и для других операционных систем. Во многие дистрибутивы Linux, ориентированные на серверную работу он устанавливается по умолчанию. Если же его нет, то установить его очень просто командой:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>openssh-server
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Естественно, удаленная машин должна быть доступна по сети с локальной. Если удаленная машина выключена, не подключена к сети или подключена к изолированной сети, куда не пройдут пакеты от локальной машины - подключиться вы к ней не сможете. Другими словами, удаленная машина должна пинговаться с локальной.</p>
<p class="notice--warning">Обратите внимание, что удаленная машина не должна быть скрыта NAT’ом или каким-либо сетевым экраном, блокирующим входящие соединения. Кстати, домание компьютеры, выходящие в интернет через обычного провайдера, как правило, как раз скрыты за NAT. Поэтому, находясь в  своей домашней сети, вы сможете подключиться к другому компьютеру в ней, а извне - нет.</p>
<p>Протокол ssh никак не связан с интернетом. Вы можете подключаться к машинам, которые подключены в общую локальную сеть, независимо от того, есть ли выход в интернет. В любом случае, вы должны знать адрес удаленной машины, чтобы к ней подключиться. Обычно используется IP-адрес. Но если у сервера есть назначенное доменное имя - можете использовать его.</p>
<p>Кроме IP-адреса нужно знать номер сетевого порта, который прослушивает сервер ssh. По умолчанию любая служба ssh использует порт 22. Однако, администраторам при настройке сервера рекомендуется ради безопасности изменить порт на случайный. Поэтому для подключения надо знать, был ли переназначен стандартный порт и, если да, то на какой.</p>
<p>Еще одно необходимое условие - знание учетной записи пользователя на удаленной машине. Помните, что после подключения вы первым делом должны будете авторизоваться на сервере. Поэтому для этого вы должны знать имя пользователя и его пароль. Этот пользователь должен быть зарегистрирован именно на удаленной машине. Ваш локальный пользователь не подойдет. Если вы сами настраиваете сервер, то такое надо предусмотреть заранее. Например завести специального пользователя, предназначенного именно для того, чтобы под ним на эту машину заходили по протоколу ssh.</p>
<p>Еще одно предостережение. На реально используемых серверах обязательно должен стоять файерволл - специальная программа, которая блокирует входящие соединения на определенные порты. Она нужна для безопасности. Так вот, по умолчанию, такие программы блокируют все порты. Если вы хотите какие-то определенные порты использовать, их надо добавить в исключения файервола.</p>
<p>Как мы уже говорили, на локальной машине должне быть установле ssh-клиент. В *nix-подобных системах (Linux, macOS) клиент обычно установлен в системе по умолчанию, и достаточно открыть терминал и воспользоваться командой ssh. В Windows нужно скачать сторонний клиент, например, Putty. SSH-клиентов тоже существует много разных. Есть даже графические клиенты. Но даже в них придется работать в командной строке - ведь сам протокол ssh - чисто текстовый.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Для подключения нужно знать адрес сервера, логин и пароль, порт подключения (по умолчанию, 22) .</li>
<li>Еще нужно, чтобы сетевая инфраструктура была правильно настроена.</li>
<li>Нужно, чтобы на удаленной машине работал сервер SSH.</li>
<li>Самый распространенный сервер - OpenSSH - бесплатный и открытый.</li>
<li>Нужно, чтобы удаленная машина была доступна по сети.</li>
<li>Системные администраторы могут заблокировать доступ к порту ssh.</li>
<li>По умолчанию, порты обычно закрыты, нужно их открыть.</li>
<li>На локальной машине должен быть установлен клиент ssh.</li>
<li>Есть консольные и графические клиенты ssh, но работать все равно придется в терминале.</li>
</ol>
</div>
<h3 id="как-подключиться-к-серверу-из-командной-строки">Как подключиться к серверу из командной строки?</h3>
<p>Для подключения нужно воспользоваться командой ssh. при запуске нужно указать адрес сервера, имя пользователя и, опционально, порт подключения. Вот как выглядит команда при использовании консольного клиента (в терминале):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh username@remote_host <span class="nt">-p</span> port
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Например, для подключения к серверу 52.307.149.244 в аккаунт user нужно ввести:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh user@52.307.149.244
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Если не указывать порт, то будет использован порт SSH по умолчанию — 22. Используемый порт задается при настройке SSH-сервера.</p>
<p>При первом подключении к конкретному серверу появится такое сообщение:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>The authenticity of host <span class="s1">'52.307.149.244 (52.307.149.244)'</span> can<span class="s1">'t be established.
ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
Are you sure you want to continue connecting (yes/no)? yes
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>Введите yes в первый раз.</p>
<p>Это нужно для повышения безопасности. При настройке SSH-сервера создается уникальная комбинация символов — fingerprint («отпечатки пальцев»). Ваш компьютер запоминает эту комбинацию и сверяет ее при каждом новом соединении. Если кто-то переустановит SSH-сервер, или всю операционную систему, или вообще заменит удаленный компьютер, сохранив его адрес, то при следующем соединении вы узнаете об этом, потому что изменится fingerprint. Если fingerprint не меняется, то такое сообщение не будет появляться.</p>
<p>Простейший вариант — подключение по паролю. После ввода команды ssh система запросит пароль:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh ivan@52.307.149.244
password: 
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Пароль придется вводить каждый раз. Обратите внимание, что пароль нужно вводить уже после установки подключения. Это сделано для того, чтобы передаваемый по сети пароль уже мог шифроваться. Ведь передавать пароли в открытом виде - очень небезопасно.</p>
<p>После подключения вы войдете в командную строку удаленной машины. В командной строке немного чего изменится.</p>
<p><img alt="styled-image" class="align-center" src="/assets/images/os_text/lx20-1.png" style="width: 800px;" title="Linux directory structure"/></p>
<p>Обратите внимание, что изменилось приглашение командной строки - теперь там отображаются данные удаленной машины, другое имя пользователя. Другое приглашение - явный знак того, что вы работаете не на своем локальном физическом компьютере.</p>
<p>Теперь можно вводить любые команды и они будут выполнены на удаленном компьютере. Порядок работы такой же, как и в обычной командной строке.</p>
<p>Для выхода из удаленного сеанса необходимо нажать комбинацию клавиш Ctrl + D. Либо можно ввести команду exit.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Команда ssh username@remote_host осуществляет подключение к удаленному терминалу.</li>
<li>Если вы подключились к этому компьютеру первый раз, нужно будет подтвердить его.</li>
<li>Опция -p позволяет подключиться по любому номеру порта.</li>
<li>После установки соединения вам нужно будет ввести пароль от удаленной учетной записи.</li>
<li>После этого вы сможете работать в командной строке так же, как и на локальной машине.</li>
<li>Для выхода из удаленного сеанса есть команда exit или сочетание Ctrl + D.</li>
</ol>
</div>
<h3 id="как-подключиться-к-серверу-по-ключу">Как подключиться к серверу по ключу?</h3>
<p>Пи работе с удаленными машинами приходится при каждом подключении вводить пароль. Если вы работаете на разных машинах, приходится запоминать все пароли от всех удаленных компьютеров. Это, конечно, безопасно, но очень неудобно. К счастью, методы асимметричного шифрования позволяют избежать этого и авторизоваться на удаленных машинах без пароля, по ключу.</p>
<p>Асимметричные шифры устроены таким образом, что всегда используют пару ключей - один для шифрования данных, а другой, парный - для расшифровки. Эта пара ключей генерируется вместе специальным алгоритмом. И по одному ключу невозможно восстановить другой. Причем расшифровать данные можно только тем ключом, который был сгенерирован в паре с тем, которым эти данные были зашифрованы.</p>
<p>Поэтому пару ключей можно использовать и для авторизации. Один из ключей - тот, что используется для шифрования - назвается приватным. Его нельзя никому передавать, показывать или пересылать. Его надо хранить в секрете. Второй ключ - публичный - используется для расшифровывания. Вот его можно передавать кому угодно. Обратите внимание, что если какие-то данные удается расшифровать вашим публичным ключом, это значит, что они были зашифрованы вашим приватным ключом, и никаким другим. А так как ваш приватный ключ знаете только вы, значит и отправили эти данные именно вы. Так публичный ключ как бы подтверждает вашу личность.</p>
<p class="notice--warning">Обратите внимание, что в такой схеме не очень соблюдается секретность передачи данных - ведь расшифровать их может кто угодно. Подробное рассмотрение алгоритмов шифрования и протоколов и схем их применения далеко выходит за рамки нашей темы. Заметим только, что в реальности для обеспечения секретности, целостности и идентификации в криптографических системах используются разные схемы. Мы сейчас рассматриваем только использование ключей для авторизации на сервере.</p>
<p>Итак, чтобы использовать авторизацию по ключу надо первым делом сгенерировать свою собственную пару ключей. Для этого используется программа ssh-keygen, которая включена в пакет ssh-клиента.</p>
<p>Создадим пару ключей:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh-keygen
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Программа запустится и спросит, куда сохранять ключи:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>Generating public/private rsa key pair.
Enter file <span class="k">in </span>which to save the key <span class="o">(</span>/home/demo/.ssh/id_rsa<span class="o">)</span>:
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Нажмите Enter для сохранения в стандартное место — директорию .ssh/id_rsa в вашей домашней директории.</p>
<p>Программа запросит passphrase. Это вроде пароля для ключа. Пароль используется для дополнительной защиты - его надо будет вводить каждый раз при использовании ключа. Идея в том, что вместо разных паролей придется запомнить только один - от ключа. Можно просто нажать Enter и пропустить этот шаг.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>Enter passphrase <span class="o">(</span>empty <span class="k">for </span>no passphrase<span class="o">)</span>:
Enter same passphrase again:
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Ключи созданы:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>Your identification has been saved <span class="k">in</span> /home/demo/.ssh/id_rsa.
Your public key has been saved <span class="k">in</span> /home/demo/.ssh/id_rsa.pub.
The key fingerprint is:
8c:e9:7c:fa:bf:c4:e5:9c:c9:b8:60:1f:fe:1c:d3:8a root@here
The key<span class="s1">'s randomart image is:
+--[ RSA 2048]----+
|                 |
|                 |
|                 |
|       +         |
|      o S   .    |
|     o   . * +   |
|      o + = O .  |
|       + = = +   |
|      ....Eo+    |
+-----------------+
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>Теперь у вас есть два файла:</p>
<ul>
<li>~/.ssh/id_rsa — приватный ключ. Никогда никому и никуда не передавайте его!</li>
<li>~/.ssh/id_rsa.pub — публичный ключ. Спокойно распространяйте его.</li>
</ul>
<p>В Windows можно использовать ssh-gen в подсистеме Ubuntu for Windows или в командной строке Git for Windows. Или создавать ключи графической утилитой вроде PuTTYgen.</p>
<p>После генерации необходимо скопировать ключ на удаленный сервер. Нужно добавить публичный ключ на сервер в файл ~/.ssh/authorized_keys. Самый простой способ — запустить на локальной машине команду для копирования ключа:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh-copy-id <span class="nt">-i</span> /home/demo/.ssh/id_rsa ivan@52.307.149.244
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Обратите внимание, что при этом придется обязательно ввести пароль от учетки на сервере. Таким образом скопированный ключ подтверждает, что его владелец знает пароль, поэтому в будущем можно его пускать без проверки.</p>
<p>Другой способ — подключиться по паролю, открыть в редакторе файл ~/.ssh/authorized_keys и добавить в конец текст из вашего файла ~/.ssh/id_rsa.pub.</p>
<p>Теперь при подключении пароль запрашиваться не будет. После включения соединений по ключу рекомендуется отключить подключение по паролю в настройках ssh сервера.</p>
<p>Один и тот же публичный ключ можно использовать для авторизации на разных серверах. Просто скопируйте его туда, куда часто заходите. Кроме обычных компьютеров, авторизация через SSH по ключу используется и на многих публичных сервисах. Например, популярный хостинг программных репозиториев GitHub заставляет использовать именно доступ по ключу для синхронизации проектов. Многие облачные сервисы так же имеют возможность авторизации по ключу.</p>
<p class="notice--danger">Только заметьте, что если вы скомпрометировали ваш приватный ключ, придется генерировать новую пару ключей. А затем придется рассылать новый публичный ключ по всем свои серверам. Причем, компрометация - это не когда вы его по ошибке где-то опубликовали, это когда возникает малейшее подозрение, что третьи лица могли получить к нему доступ.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Запоминать много паролей от серверов часто неудобно и небезопасно.</li>
<li>Асимметричное шифрование позволяет избежать ввода пароля каждый раз.</li>
<li>Команда ssh-keygen позволяет сгенерировать пару ключей - приватный и публичный.</li>
<li>Приватный ключ надо хранить в секрете. Если он скомпрометирован, придется создавать новую пару.</li>
<li>Публичный ключ может удостоверять подлинность отправителя.</li>
<li>Можно скопировать публичный ключ на сервер командой ssh-copy-id -i.</li>
<li>Ключ может быть разослан на несколько серверов, и на них можно заходить без пароля.</li>
<li>Ключ тоже можно защитить паролем.</li>
</ol>
</div>
<h3 id="как-запомнить-частые-подключения">Как запомнить частые подключения?</h3>
<p>При работе с многими удаленными серверами кроме паролей приходится запоминать еще много информации: ip-адреса, имена пользователей на каждом сервере, номера нестандартных портов, которые тоже могут отличаться, другие опции. Это не так критично, как пароли, но все равно может доставить неудобств.</p>
<p>В стандартном клиенте ssh предусмотрена возможность запомнить частые подключения в конфигурационном файле. Он располагается по адресу ~/.ssh/config. Если его там нет, вполне можно создать новый пустой. Вообще, папка ~/.ssh/ - это общее место, где собираются многие файлы, имеющие отношение к входящим или исходящим подключениям по ssh. Например, именно туда сохраняются файлы ключей и публичные ключи удаленных пользователей.</p>
<p>Этот файл имеет довольно простую структуру. В нем прописывается символьное имя подключения, которые вы будете использовать вместо строки подключения в команде ssh. После этого могут идти несколько опций, например - имя пользователя, адрес хоста, номер порта, адрес публичного ключа, который будет использоваться при подключении. Выглядит это примерно так:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>Host targaryen
    HostName 192.168.1.10
    User daenerys
    Port 7654
    IdentityFile ~/.ssh/targaryen.key

Host tyrell
    HostName 192.168.10.20
    user oberyn

Host martell
    HostName 192.168.10.50
</pre></td></tr></tbody></table></code></pre></div></div>
<p>У этого файла довольно много опций, но эти - самые полезные. После того, как в файл добавлена запись можно подключаться к хосту только по алиасу, например так:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>ssh targaryen
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Все остальные параметры клиент подставит сам.</p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>Файл ~/.ssh/config используется, чтобы запомнить часто использующиеся подключения.</li>
<li>Можно присвоить символьное имя и связать его с адресом, именем пользователя.</li>
<li>В этом файле можно прописать использование определенного файла ключа.</li>
<li>Файл приватного ключа в таком случае выступает идентификацией (identity).</li>
</ol>
</div>
<h3 id="зачем-нужна-программа-tmux">Зачем нужна программа Tmux?</h3>
<p>При работе в удаленной сессии есть один подводный камень. Из-за особенности функционирования процессов в Linux, когда мы выходим из сеанса (разлогиниваемся), то все запущенные команды и программы автоматически завершатся. Следующий раз нам приходится начинать работы с самого начала. И нельзя запустить какой-то долгий процесс, чтобы он выполнялся, пока мы отключились. Такое происходит и в случае непреднамеренного отключения, например, при обрыве связи.</p>
<p>Чтобы обойти это ограничение, существуют специальные программы. Они не входят в стандартные дистрибутивы, так что их придется устанавливать отдельно. Такие программы работают резидентно, то есть в режиме сетевой службы и поэтому могут поддерживать сеанс даже после того, как пользователь отключился.</p>
<p>Tmux (terminal multiplexor) - популярная программа, значительно
облегчающая работы в терминале на удаленной машине. Среди
возможностей данной программы:</p>
<ul>
<li>разделение экрана на несколько консолей</li>
<li>создание нескольких экранов</li>
<li>сохранение выполняющихся процессов на удаленной машине после выхода из сессии</li>
<li>расшаривание ssh сессий нескольким пользователям</li>
</ul>
<p>То есть кроме поддержания сессии tmux сильно “прокачивает” стандартную командную строчку. Это очень упрощает и ускоряет сложную работу на сервере.</p>
<p>Для начала работы необходимо подключиться к удаленной машине по ssh.
Конечно, можно использовать программу tmux на локальной машине для
расширения возможностей терминала, но здесь мы рассмотрим возможности
этой программы при удаленном доступе к терминалу.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image16.png" style="width: 800px;"/></p>
<p>При необходимости нужно установить tmux, введя команду</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>sudo apt install tmux
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Обратите внимание, что эта программа должна быть установлена именно на той машине, на которой вы будете выполнять команды. То есть, если вы планируете использовать ее для работы на удаленном сервере, то именно в нем она и должна быть установлена. Если она есть только на вашей локальной машине, на сервере она не заработает.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image21.png" style="width: 800px;"/></p>
<p>Теперь можно запустить tmux, введя одноименную команду:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image7.png" style="width: 800px;"/></p>
<p>На экране мы видим главное окно программы tmux:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image9.png" style="width: 800px;"/></p>
<p>Сочетание клавиш &lt;Ctrl&gt;+B позволяет вводить команды tmux. Наиболее
применимые команды:</p>
<ul>
<li>ctrl-b c - запуск нового окна;</li>
<li>ctrl-b , - переименование окна;</li>
<li>ctlb-b p - переключение к предыдущему окну;</li>
<li>ctlb-b n - переключение к следующему окну;</li>
<li>ctlb-b w - вывести список окон;</li>
<li>ctlb-b % - разделение окна вертикально на две панели;</li>
<li>ctlb-b “ - разделение окна горизонтально;</li>
<li>ctlb-b d - отсоединиться от сессии;</li>
</ul>
<p>Обратите внимание, сначала надо зажать &lt;Ctrl&gt;+B именно как комбинацию клавиш. Потом отпустить и сразу нажать клавишу, соответствующую нужной команде. Поначалу такая работа покажется очень неудобной, но со временем вы привыкните к такому оригинальному методу ввода команд.</p>
<p>Обратите внимание на нижнюю строчку. Здесь перечислены открытые окна
терминала. Можно воспринимать их как вкладки, по которым можно
перемещаться. Мы можем создать новое окно (ctrl-b c):</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image8.png" style="width: 800px;"/></p>
<p>Теперь мы видим, что в нижней строке появилось окно 1. Звездочкой
обозначено текущее окно.</p>
<p>Мы можем также переименовать окно (ctrl-b ,), чтобы лучше ориентироваться. Это бывает полезно для организации рабочего пространства.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image5.png" style="width: 800px;"/></p>
<p>Теперь мы имеем второе окно (под номером 1, так как нумерация начинается с 0) с именем window1.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image20.png" style="width: 800px;"/></p>
<p>Давайте для иллюстрации запустим в первом окне команду htop:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image19.png" style="width: 800px;"/></p>
<p>Tmux позволяет вывести список всех созданных окон (ctrl-b w), в котором можно
перемещаться между ними. Также доступен предварительный просмотр
содержимого каждого окна:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image18.png" style="width: 800px;"/></p>
<p>Работая в этой программе можно также разделять пространство в отдельно
взятом окне на две панели. В каждой панели можно работать независимо,
вводить команды и наблюдать результат одновременно.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image1.png" style="width: 800px;"/></p>
<p>Текущее окно или панель можно разбить на две панели как вертикально (ctrl-b %), так и горизонтально (ctrl-b "). Панели можно дробить неограниченное число раз:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image10.png" style="width: 800px;"/></p>
<p>При выполнении команды exit (или ctrl-d) панель закрывается.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image17.png" style="width: 800px;"/></p>
<p>Если эта панель была единственной в окне - то закроется все окно, а если окно было единственным - программа tmux завершится.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image6.png" style="width: 800px;"/></p>
<p>Еще одной возможностью tmux является работа с сессиями. Если
использовать сессии, то вместо выхода из сессии подключения
к удаленной машине можно отключиться от сессии, а при повторном
подключении сессия сессия сохранит свое состояние. То есть, все
процессы, запущенные на удаленной машине так и будут продолжать
выполняться.</p>
<p>Для запуска сессии необходимо запустить tmux со специальным параметром, указав имя сессии:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image11.png" style="width: 800px;"/></p>
<p>Запустим в этой сессии какой-нибудь интерактивный процесс:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image14.png" style="width: 800px;"/></p>
<p>Нажав сочетание клавиш ctrl-b d, отсоединимся от сессии:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image3.png" style="width: 800px;"/></p>
<p>При помощи команд терминала можно убедиться, что программа, которую мы запустили все еще работает, несмотря на то, что мы вышли из
родительского процесса.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image12.png" style="width: 800px;"/></p>
<p>Можно даже выйти из подключения к удаленной машине и спустя некоторое
время зайти обратно.</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image13.png" style="width: 800px;"/></p>
<p>При запуске tmux можно вывести список всех открытых сессий:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image4.png" style="width: 800px;"/></p>
<p>Соответственно, можно вместо запуска нового терминала подключиться к
одной из существующих сессий:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image2.png" style="width: 800px;"/></p>
<p>Как мы можем наблюдать, терминал остался в том же состоянии, в котором мы его оставили, когда выходили из сессии:</p>
<p><img alt="" class="align-center" src="/assets/images/os_text/lx2-2/image15.png" style="width: 800px;"/></p>
<div class="notice--info">
<p>Выводы:</p>
<ol>
<li>При отключении от удаленного хоста все запущенные процессы завершатся.</li>
<li>Иногда нужно запустить процесс так, чтобы он продолжался на сервере после отключения.</li>
<li>Для этого существуют специальные резидентные программы, например, tmux.</li>
<li>Tmux организует сессии, которые продолжаются даже после отключения пользователя.</li>
<li>Также вы можете продолжать работу с того места, с которого отключились.</li>
<li>Tmux позволяет создавать несколько вкладок, разбивать окно терминала на области.</li>
<li>Tmux сильно упрощает работу с терминалом и с удаленными серверами.</li>
<li>Для работы tmux должен быть установлен на удаленном сервере.</li>
</ol>
</div>
</div>
<header class="caption">
<h1>Использование удаленного доступа по SSH</h1>
<!-- <p>Yours Truly, Famous Inc.</p> -->
</header>
<section class="slide">
<h2 class="shout">Использование удаленного доступа по SSH</h2>
</section>
<footer class="badge">
<a href="https://github.com/shower/shower">Build with shower</a>
</footer>
<script src="/assets/shower/shower.js"></script>
<!-- Copyright © 3000 Yours Truly, Famous Inc. -->
<script type="text/javascript">
        
        const content = document.querySelector('#temp');
        const childern = content.childNodes;

        let current_slide;
        let points;
        let code;
        let image;
        let misc;

        function commit() {
            if (current_slide) {

                const elems = [image, code, points, misc];

                let slide;

                elems.forEach(elem => {
                    if (elem) {
                        // console.log("ИТЕРАЦИЯ " + current_slide);
                        // console.log([image, code, points, misc]);

                        slide = document.createElement('section');
                        slide.className = "slide";
                        let slide_header = document.createElement('h2');
                        slide_header.innerHTML = current_slide;
                        slide.appendChild(slide_header);

                        slide.appendChild(elem);

                        document.body.appendChild(slide);

                        fit_in_slide(elem);
                    }
                });

                misc = undefined;
                points = undefined;
                image = undefined;
                code = undefined;
            }
        }

        function fit_in_slide(element) {
            console.log("ИТЕРАЦИЯ " + current_slide);
            console.log(element);

            let ratio = Math.min(
            	550 / element.offsetHeight,
            	// 1600 / element.offsetWidth,
            	);


            let new_size = Math.sqrt(ratio) / 1.2;
            if (new_size > 2.5) {
                new_size = 2.5
            }
            element.style["font-size"] = new_size + "em";

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            ratio = Math.min(
            	550 / element.offsetHeight,
            	1600 / element.offsetWidth,
            	);

            new_size = Math.pow(ratio, 1.1) * 12;
            if (new_size > 30) {
                new_size = 30
            }

            console.log(element.innerHTML);            
            console.log(element.querySelectorAll("*"));            
            console.log(element.querySelectorAll("pre"));

            element.querySelectorAll("pre").forEach(e => {
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            element.querySelectorAll("span").forEach(e => {
            	console.log("found");
                e.style["font-size"] = new_size + "px";
                e.style["line-height"] = new_size * 1.2 + "px";
            });

            console.log(
                // realHeight, ratio, 
                new_size, 
                element.offsetHeight,
                element.offsetWidth);

            return element;
        }

        childern.forEach(elem => {
            if (elem.tagName == "H3") {
                commit();
                let slide = document.createElement('section');
                slide.className = "slide";
                let slide_header = document.createElement('h2');
                slide_header.className = "shout shrink"
                slide_header.innerHTML = elem.innerHTML;
                slide.appendChild(slide_header);

                // slide.appendChild(elem);

                document.body.appendChild(slide);
            }

            if (elem.tagName == "H3" || elem.tagName == "H4") {
                commit();
                current_slide = elem.innerHTML;
            }

            else if (elem.tagName == "DIV" && elem.classList.contains("notice--info")) {
                let list = elem.getElementsByTagName('ol')[0];

                list.childNodes.forEach(elem => {
                    elem.className = "next";
                });

                points = list;
                // points = fit_in_slide(points);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("highlighter-rouge")) {
                code = elem;
                commit()
                // code = fit_in_slide(code);
            } 

            else if (elem.tagName == "DIV" && elem.classList.contains("presentation")) {
                misc = elem;
                // misc = fit_in_slide(misc);
                commit();
            } 

            else if (elem.tagName == "P" && elem.getElementsByTagName('img').length > 0) {
                image = elem.getElementsByTagName('img')[0];
                image.style.width = "auto";
                commit();
            } 
        });

        commit();

        content.remove();

    </script>
<div class="progress"></div>
<script src="/assets/js/main.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1K09X3NDBE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1K09X3NDBE', { 'anonymize_ip': false});
</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(77706580, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img alt="" src="https://mc.yandex.ru/watch/77706580" style="position:absolute; left:-9999px;"/></div></noscript>
<!-- /Yandex.Metrika counter -->
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</body>
</html>
