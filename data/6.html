<!DOCTYPE html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
--><html class="no-js" lang="ru">
<head>
<meta charset="utf-8"/>
<!-- begin _includes/seo.html --><title>LX1 Основы командной строки | Михаил Коротеев</title>
<meta content="" name="description"/>
<meta content="Михаил Коротеев" name="author"/>
<meta content="Михаил Коротеев" property="article:author"/>
<meta content="article" property="og:type"/>
<meta content="ru_RU" property="og:locale"/>
<meta content="Михаил Коротеев" property="og:site_name"/>
<meta content="LX1 Основы командной строки" property="og:title"/>
<meta content="https://koroteev.site/os/1/1-cli/" property="og:url"/>
<meta content="" property="og:description"/>
<meta content="https://koroteev.site/assets/images/android-chrome-192x192.png" property="og:image"/>
<meta content="@koroteev_m" name="twitter:site"/>
<meta content="LX1 Основы командной строки" name="twitter:title"/>
<meta content="" name="twitter:description"/>
<meta content="https://koroteev.site/os/1/1-cli/" name="twitter:url"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://koroteev.site/assets/images/android-chrome-192x192.png" name="twitter:image"/>
<meta content="2022-09-27T12:49:07+00:00" property="article:published_time"/>
<link href="https://koroteev.site/os/1/1-cli/" rel="canonical"/>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Михаил Коротеев",
      "url": "https://koroteev.site/"
    
  }
</script>
<meta content="77706580" name="yandex-verification"/>
<!-- end _includes/seo.html -->
<link href="/feed.xml" rel="alternate" title="Михаил Коротеев Feed" type="application/atom+xml"/>
<!-- https://t.co/dKP3o1e -->
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>
<!-- For all browsers -->
<link href="/assets/css/main.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" rel="stylesheet"/>
<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->
<!-- start custom head snippets -->
<style type="text/css">
.accordion {
  border: 1px solid white;
  padding: 0 10px;
  margin: 0 auto;
  list-style: none outside;
}

.accordion > * + * { border-top: 1px solid white; }

.accordion-item-hd {
  display: block;
  padding: 15px 30px 15px 0;
  position: relative;
  cursor: pointer;
  font-size: 18px;
  font-weight: bold;
}

.accordion-item-input:checked ~ .accordion-item-bd {
  max-height: 1000px;
  padding-top: 15px;
  margin-bottom: 15px;
  -webkit-transition: max-height 1s ease-in, margin .3s ease-in, padding .3s ease-in;
  transition: max-height 1s ease-in, margin .3s ease-in, padding .3s ease-in;
}

.accordion-item-input:checked ~ .accordion-item-hd > .accordion-item-hd-cta {
  -webkit-transform: rotate(0);
  -ms-transform: rotate(0);
  transform: rotate(0);
}

.accordion-item-hd-cta {
  display: block;
  width: 30px;
  position: absolute;
  top: calc(50% - 6px );
  /*minus half font-size*/
  right: 0;
  pointer-events: none;
  -webkit-transition: -webkit-transform .3s ease;
  transition: transform .3s ease;
  -webkit-transform: rotate(-180deg);
  -ms-transform: rotate(-180deg);
  transform: rotate(-180deg);
  text-align: center;
  font-size: 12px;
  line-height: 1;
}

.accordion-item-bd {
  max-height: 0;
  margin-bottom: 0;
  overflow: hidden;
  -webkit-transition: max-height .15s ease-out, margin-bottom .3s ease-out, padding .3s ease-out;
  transition: max-height .15s ease-out, margin-bottom .3s ease-out, padding .3s ease-out;
}

.accordion-item-input {
  clip: rect(0 0 0 0);
  width: 1px;
  height: 1px;
  margin: -1;
  overflow: hidden;
  position: absolute;
  left: -9999px;
}
</style>
<!-- insert favicons. use https://realfavicongenerator.net/ -->
<!-- end custom head snippets -->
</head>
<body class="layout--coursepage">
<nav class="skip-links">
<h2 class="screen-reader-text">Skip links</h2>
<ul>
<li><a class="screen-reader-shortcut" href="#site-nav">Skip to primary navigation</a></li>
<li><a class="screen-reader-shortcut" href="#main">Skip to content</a></li>
<li><a class="screen-reader-shortcut" href="#footer">Skip to footer</a></li>
</ul>
</nav>
<!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->
<div class="masthead">
<div class="masthead__inner-wrap">
<div class="masthead__menu">
<nav class="greedy-nav" id="site-nav">
<a class="site-logo" href="/"><img alt="" src="/assets/images/android-chrome-192x192.png"/></a>
<a class="site-title" href="/">
          Михаил Коротеев
          <span class="site-subtitle">Личный сайт</span>
</a>
<ul class="visible-links"><li class="masthead__menu-item">
<a href="/os">UNIX</a>
</li><li class="masthead__menu-item">
<a href="/ml">ML</a>
</li><li class="masthead__menu-item">
<a href="/md">Android</a>
</li><li class="masthead__menu-item">
<a href="/courses">Все курсы</a>
</li><li class="masthead__menu-item">
<a href="/blog/">Блог</a>
</li><li class="masthead__menu-item">
<a href="/science">Проекты</a>
</li></ul>
<button class="greedy-nav__toggle hidden" type="button">
<span class="visually-hidden">Выпадающее меню</span>
<div class="navicon"></div>
</button>
<ul class="hidden-links hidden"></ul>
</nav>
</div>
</div>
</div>
<div class="initial-content">
<div id="main" role="main">
<div class="sidebar sticky">
<nav class="nav__list">
<input id="ac-toc" name="accordion-toc" type="checkbox"/>
<label for="ac-toc">Выпадающее меню</label>
<ul class="nav__items">
<li>
<a href="/os/"><span class="nav__sub-title">Содержание курса</span></a>
</li>
<li>
<span class="nav__sub-title">1. Основы Linux</span>
<ul>
<li><a href="/os/1/0-vm_installation/">Введение</a></li>
<li><a class="active" href="/os/1/1-cli/">Командная строка</a></li>
<li><a href="/os/1/2-ssh/">Использование ssh</a></li>
<li><a href="/os/1/3-users/">Пользователи и права</a></li>
<li><a href="/os/1/4-processes/">Архитектура, пакеты, процессы</a></li>
</ul>
</li>
<li>
<span class="nav__sub-title">2. Администрирование Linux</span>
<ul>
<li><a href="/os/2/1-init/">Управление загрузкой</a></li>
<li><a href="/os/2/1-filesystems/">Файловые системы</a></li>
<li><a href="/os/2/3-bash/">Основы скриптов на bash</a></li>
<li><a href="/os/2/4-text/">Средства обработки текста</a></li>
<li><a href="/os/2/5-network/">Настройка сети</a></li>
</ul>
</li>
<li>
<span class="nav__sub-title">3. Сетевое программирование</span>
<ul>
<li><a href="/os/3/0-environment/">Настройка окружения Python</a></li>
<li><a href="/os/3/2-git/">Системы контроля версий</a></li>
<li><a href="/os/3/3-sockets/">Использование сокетов</a></li>
<li><a href="/os/3/4-threading/">Асинхронное программирование</a></li>
<li><a href="/os/4/1-tls/">Безопасность в сетях</a></li>
<li><a href="/os/4/2-web-server/">Веб-служба</a></li>
<li><a href="/os/4/5-deploy/">Развертывание приложений</a></li>
</ul>
</li>
</ul>
</nav>
</div>
<article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
<meta content="LX1 Основы командной строки" itemprop="headline"/>
<meta content="" itemprop="description"/>
<meta content="2022-09-27T12:49:07+00:00" itemprop="datePublished"/>
<div class="page__inner-wrap">
<header>
<h1 class="page__title" id="page-title" itemprop="headline">LX1 Основы командной строки
</h1>
</header>
<section class="page__content" itemprop="text">
<aside class="sidebar__right sticky">
<nav class="toc">
<header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Содержание</h4></header>
<ul class="toc__menu">
<li><a href="#Лекция: Основы командной строки Linux"> Лекция: Основы командной строки Linux</a>
<ul>
<li><a href="#1-video">Видео занятия</a></li>
<li><a href="#1-slides">Презентация</a></li>
<li><a href="#1-test">Тестирование</a></li>
</ul>
</li>
<li><a href="#Практика: 10 основных команд"> Практика: 10 основных команд</a>
<ul>
<li><a href="#2-video">Видео занятия</a></li>
</ul>
</li>
<li><a href="#Практика: Служебные команды"> Практика: Служебные команды</a>
<ul>
<li><a href="#3-video">Видео занятия</a></li>
</ul>
</li>
<li><a href="#Лекция: Работа с файлами"> Лекция: Работа с файлами</a>
<ul>
<li><a href="#4-slides">Презентация</a></li>
</ul>
</li>
<li><a href="#Практика: Работа с файлами"> Практика: Работа с файлами</a></li>
</ul>
</nav>
</aside>
<h2 id="Лекция: Основы командной строки Linux"> Лекция: Основы командной строки Linux</h2>
<p> В данной лекции рассматриваются основные приемы работы с командной строкой Linux. Вы поймете, зачем нужно пользоваться командной строкой, какова структура команды, как находить информацию по командам. </p>
<h3 id="1-video">Видео занятия</h3>
<div class="responsive-video-container">
<iframe allowfullscreen="" frameborder="0" mozallowfullscreen="" src="https://www.youtube-nocookie.com/embed/QjYEkVXH4t4" webkitallowfullscreen="">
</iframe>
</div>
<h3 id="1-slides">Презентация</h3>
      Смотреть <a href="/pres/os11-0/">слайды</a> к этому занятию.
  

      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
<div>
  ### Зачем нужна командная строка?


![alt_text](/assets/images/os_text/lx10-1.png "image_tooltip"){: .align-center style="width: 900px;"}


Командная строка - это основной способ взаимодействия с операционными системами семейства UNIX. Все современные дистрибутивы для общего пользования включают и графическое окружение, которое позволяет обычному пользователю работать в оконном интерфейсе, без освоения командного интерпретатора. Но при необходимость выполнения служебных действий, практически всегда приходится обращаться к командной строке.

Команды позволяют выполнить практически любой действие с операционной системой. В отличие от Windows, в Linux чем более продвинутый пользователь, тем чаще ему приходится залезать в командную строку. Профессионалы работают с ней постоянно. Именно поэтому мы с вами будем изучать ее, чтобы работа в терминале не пугала нас, а наоборот, мы чувствовали себя там комфортно.

Команды значительно более гибкие и мощные, нежели графические оболочки. Графический интерфейс сильно ограничивает ваши возможности по взаимодействию с системой: вы можете выполнить только определенные действия и только в определенном порядке. Используя команды оболочки, можно выполнять любые действия, предусмотренные командной оболочкой, запускать любые программы и комбинировать их в любой последовательности

Сейчас мы будем употреблять термины “командная строка”, “оболочка”, “терминал”, “bash” и “командный интерпретатор” как синонимы. Между ними есть определенная разница, но в самом начале, чтобы не путаться, можно не обращать на нее внимания. Все эти термины относятся к способу взаимодействия пользователя с системой через ввод текстовых команд. Вообще, в Linux существует много разных командных интерпретаторов, построенных на основе разных языков программирования. Но с большим отрывом самый популярный - это bash. Именно про него мы и будем говорить дальше.

Командная строка работает по принципу REPL. То есть вы вводите команду, нажимаете &lt;Enter&gt;, в этот момент она исполняется, результат выводится на экран и вы можете вводить следующую. Однако, следует помнить, что некоторые команды являются интерактивными, то есть они выполняются, пока пользователь их явно не прервет.

Недостаток командной строки - отсутствие интуитивного интерфейса. Для совершения определенного действия необходимо знать команду, которая это действие совершает. В графическом интерфейсе можно сориентироваться, даже если вы не знаете точно что нужно делать, вы можете догадаться по названиям пунктов меню, пиктограмм, расположению на экране. В командной строке не так, только вы и черный экран. Поэтому сначала надо изучить хотя бы основные команды, а уже потом начинать работать. Сразу скажем, что работа в командной строке поначалу может показаться непривычной и даже неудобной. Это нормально, ощущение дискомфорта уйдет в процессе привыкания. На самом деле совершать определенные действия в командной строке гораздо удобнее, чем тыкать в кнопочки. Недаром большинство профессиональных администраторов, программистов и ученых предпочитают работать текстом, даже если есть графический инструмент для нужного действия.

Самое главное достоинство командной строки - удобство автоматизации. Командная строка - это еще и язык программирования. Если вы часто совершаете однотипные действия в командной строке вы можете просто записать их в скрипт и выполнять его. Ведь каждая команда - это по сути дела строчка в программе. В скриптах вы можете делать еще кучу всего - использовать условия, циклы, функции. Вы можете обращаться к командной строке из своих программ, на любом языке программирования. То есть при помощи командной строки вы можете производить комплексную автоматизацию. А вот автоматизировать действия в графическом интерфейсе наоборот, невероятно сложно.

{% capture notice-2 %}
Выводы:
1. Для Linux командная строка - основной способ взаимодействия с пользователем.
2. Самый распространенный интерпретатор командной строки в Linux - bash.
3. Командная строка пугает, это нормально.
4. Самое главное достоинство командной строки - удобство автоматизации.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как туда попасть?


![alt_text](/assets/images/os_text/lx10-2.png "image_tooltip"){: .align-center style="width: 750px;"}


Изначально, терминал - это интерфейс ввода/вывода, состоящий из физических устройства ввода (клавиатура) и вывода (дисплей). Терминал предназначен исключительно для ввода информации и ее отображения на экране. Терминалы бывают физическими (реальными), виртуальными и псевдотерминалами (т.е. программами, которые "притворяются" терминалами). Не останавливаясь на подробностях работы реальных терминалов отметим, что при работе чаще всего вы будете использовать виртуальные терминалы и эмуляторы.

В системах Linux еще существуют несколько виртуальных терминалов. По умолчанию Линукс представляет доступ к шести текстовым терминалам, которые соответственно называются tty1, tty2 и т.д. Переключение между ними осуществляется сочетанием клавиш Ctrl+F1, Ctrl+F2, Ctrl+F3 и т.д. В современных дистрибутивах в одном из терминалов (обычно под номером 7) загружена графическая оболочка и этот терминал открывается по умолчанию. При загруженной графической оболочке открытие терминалов и переключение между ними производится клавишами Alt+Ctrl+Fn, (где n - номер терминала). Сама графическая оболочка будет доступна по Alt+Ctrl+F7. Для работы в каждом новом терминале вы должны прежде всего авторизоваться. Таким образом, в системе одновременно могут работать несколько различных пользователей, каждый в своем терминальном сеансе.

Если вы используете десктопный дистрибутив, то в одном из виртуальных терминалов запускается графическая оболочка. Именно он обычно и запускается по умолчанию. Поэтому при старте системы вы видите графический интерфейс. Но, кстати, для самой операционки, это просто такая специальная программа, запускаемая автоматически при загрузке в седьмом (обычно) виртуальном терминале

Самый простой способ - открыть программу-эмулятор терминала. В любой графической системе есть такая программа, которая открывает командную строку прямо в окне. Это удобно, так как не надо переключаться в другой терминал и логиниться там. Вы уже работаете в сеансе пользователя. Кроме того, такие программы-эмуляторы обычно содержат дополнительные функции, например, подсветку синтаксиса, масштабирование, прозрачность, вкладки.

{% capture notice-2 %}
Выводы:
1. Терминал в старой терминологии - конечное устройство ввода-вывода пользователя.
2. При запуске Linux создает несколько виртуальных терминалов.
3. Для того, чтобы начать работать с терминалом, нужно, залогиниться.
4. Существуют графические программы-эмуляторы терминала.
5. За разными терминалами могут работать разные пользователи. А может и один.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что вы видите на экране командной оболочки?


![alt_text](/assets/images/os_text/lx10-3.png "image_tooltip"){: .align-center style="width: 750px;"}


Когда вы открываете терминал, необходимо найти текущее положение курсора. Он обычно обозначается мигающей вертикальной чертой или знаком подчеркивания. Курсор обозначает то место, где будут появляться символы при их вводе с клавиатуры. 

Все, что отображается в строке непосредственно перед курсором еще до того, как вы начали что-то вводить - это приглашение командной строки. Это строка определенного вида, которая отображается каждый раз перед вводом команды. Даже само ее название означает, что она приглашает вас ввести какую-нибудь команду. Если вы привыкли к виду приглашения командной строки, оно поможет вам ориентироваться в терминале. Кроме того, приглашение содержит некоторую полезную информацию.

Вид приглашения зависит от используемой оболочки и часто может настраиваться пользователем. Но мы пока рассмотрим стандартное приглашение оболочки по умолчанию. Оно обычно состоит из четырех частей.

Самым первым отображается имя текущего пользователя. 

Далее после символа @ идет название текущего хоста (экземпляра операционной системы). Имя хоста обычно употреблаяется для обозначения текущего компьютера. Если вы работаете только за одним компьютером, вам может показаться, что это не очень полезное знание. Но в работе системного администратора часто возникает необходимость подключаться удаленно к разным хостам. И забыть, в консоли какого компьютера ты сейчас находишься - это не так странно, как может показаться. 

Далее отображается имя текущей папки. Очень важный факт про консоль - в ней мы не можем находиться “просто так”, мы всегда находимся в какой-то папке на диске. Это имя “текущей директории”. Мы можем перемещаться между папками, или обращаться к файлам других папок, но в любой момент работы название текущей директории отображается в приглашении, чтобы мы всегда могли просто посмотреть, где мы сейчас. 

Если вы только запустили терминал, то скорее всего находитесь в домашней папке. Она обозначается для краткости специальным символом \~. У каждого зарегистрированного пользователя есть своя домашняя папка.


{% capture notice-2 %}
Выводы:
1. Курсор в терминале - это то, куда вводить буквы с клавиатуры.
2. Приглашение командной строки - это полезная информация о вашем состоянии.
3. В приглашении по умолчанию отображается имя пользователя, имя хоста и текущая папка.
4. В терминале можно перемещаться по папкам.
5. Вид терминала и приглашения можно настраивать.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Какие команды изучить в первую очередь?


![alt_text](/assets/images/os_text/lx10-4.png "image_tooltip"){: .align-center style="width: 750px;"}


Для работы в консоли необходимо знать команды. Интуитивным интерфейсом здесь не обойдешься. Изучение команд - это вопрос времени и практики. Чем больше вы работаете в системе, тем лучше ее знаете. Поэтому настоятельно рекомендуется как можно чаще пользоваться командной строкой в процессе изучения системы. Так вы сможете выработать привычку и освоить базовые команды не путем заучивания, а естественно.

90% вашего времени вы будете использовать самые базовые команды - переходы по папкам, создание и перемещение файлов и аналогичные. В этом разделе мы перечислим десять самых базовых команд, с которых удобнее всего начинать изучение командной строки и языка bash:

1. _pwd_ (print working directory) - отобразить текущую директорию.
2. _ls [&lt;dirname&gt;]_ (list) - вывести список файлов и папок в текущей директории. В linux директории считаются наряду с обычными файлами. ls Desktop - вывести список файлов в другой директории.
3. _cd [&lt;dirname&gt;]_ (change directory) - изменить текущую директорию. Для удобства, чтобы не указывать у файлов и папок постоянно путь к ним из текущей директории, можно изменить текущую директорию на ту, с которой вы работаете сейчас.
4. _cat &lt;filename&gt;_ (concatenate) - вывести на консоль (в стандартный вывод) содержимое текстового файла, имя которого передано как параметр. Можно передать несколько файлов, тогда они “склеятся”
5. _mkdir &lt;dirname&gt;_ (make a directory) - создание директории (папки). Параметром передается имя новой папки. Папка создается в текущей директории. Если здесь уже есть файл или папка с таким именем, то команда завершится с ошибкой.
6. _touch &lt;filename&gt;_ - вообще данная команда обновляет дату и время последнего доступа к переданному файлу. Если такого файла нет, то файл будет создан. Чаще всего эта команда используется для создания новых пустых файлов.
7. _rm &lt;filename&gt; _(remove) - удаление файла. При помощи опций данная команда может удалять и директории. Обратите внимание, что удаление происходи насовсем. Никакая корхина в командной строке не предусмотрена. Поэтому этой командой надо пользоваться осторожно.
8. _cp &lt;src&gt; &lt;dest&gt;_ (copy) - копирование файла. Данной команде надо передать два параметра - имя копируемого файла и имя файла (возможно в другой папке), куда его необходимо скопировать. Очень часто в подобных случаях действует правило откуда - куда (сначала указывается имя исходного файла или папки, а потом - целевой папки или файла).
9. _mv &lt;src&gt; &lt;dest&gt;_ (move) - то же самое, только происходит не копирование, а перемещение файла. Если производить перемещение в ту же папку, где файл и был, он запишется с другим именем. Часто эта команда используется именно для переименования файлов.
10. _man &lt;command&gt;_ (manual) - получение справки по команде. Это, наверное, самая полезная команда, ей нужно пользоваться как можно чаще. Встроенная справка (мануал) - это самый главный, полный и актуальный источник информации о командах и их параметрах.


### Как выполняются команды?


![alt_text](/assets/images/os_text/lx10-5.png "image_tooltip"){: .align-center style="width: 750px;"}


Каждая команда при своем выполнении (в тот момент, когда мы нажимаем Enter после самой команды) запускает определенный алгоритм, чаще всего - целую отдельную программу. Некоторые команды завершаются моментально (pwd), а другие (ping) - выполняются продолжительное время. Кроме того, некоторые команды запускают интерактивные программы (top). При работе с терминалом важно понимать, сколько будет выполняться та или иная команда. 

Командная строка работает по принципу REPL (read - execute - print - loop), то есть после ввода команда тут же начинает выполняться, причем все, что эта команда выводит на печать отображается в том же терминале, в котором эта команда была введена. Поэтому для того, чтобы разные команды не смешивались, пока одна команда выполняется, она полностью блокирует собой этот терминал. То есть вы не сможете вводить другие команды, пока первая не завершится. После завершения команда освобождает занятый терминал, в нем автоматически снова выводится приглашение командной строки и цикл завершается, вы можете вводить следующую.

Большинство простых команд, таких как копирование файлов, создание директорий и другие, созданные для совершения одного определенного действия выполняются практически моментально. Большинство из этих команд - это стандартные служебные программы из проекта GNU, которые адаптировал существовавшее в UNIX рабочее окружение. Именно поэтому стандартные команды общие для всех дистрибутивов Linux, да и в других UNIX-подобных операционных системах они более-менее такие же. 

Для таких простых стандартных команд часто действует определенная философия  - команда должна принимать входную информацию либо через параметры, либо читать из переданного файла, и выводить информацию в консоль только чтобы сообщить об ошибке. Таким образом, чаще всего данные команды завершаются мгновенно и не выводят ничего. И именно такое поведение свидетельствует о том, что необходимые действия совершены успешно. Но новички часто думают, что если команда ничего не вывела, то она по каким-то причинам не отработала. В UNIX зачастую это не так.

Конечно, существуют команды, цель которых отобразить информацию в терминале. Типичный пример - команда ls. Она выводит список файлов в каталоге. Естественно, она должна выводить его на свой стандартный вывод. Еще, существуют команды, которые работают долгое время и выводят много информации в терминал. Например, так устроена команда find - поиск файлов по имени, команда ping вообще будет работать неопределенно долго, пока пользователь сам явне не прервет ее. 

Но в любом случае, такие неинтерактивные команды стараются как можно реже запрашивать информацию у пользователя через стандартный ввод. Это сделано специально для того, чтобы команды можно было объединять в конвейеры или скрипты, то есть программы. Строить программу их интерактивных блоков довольно сложно, а из простых “кирпичиков” - очень легко. И зачастую администраторам приходится писать такие служебные скрипты, что гораздо удобнее, чем каждый раз вводить несколько команд руками.

Отдельно надо сказать о так называемых интерактивных командах. Их очень немного, но они работают в совершенно особом режиме. После запуска они полностью занимают терминал, обычно еще и полностью очищают окно. Зачастую у них присутствует псевдографический интерфейс. И в процессе своей работы пользователь может взаимодействовать с ними при помощи их собственных сочетаний клавиш, каких-то внутренних команд до тех пор, пока не выйдет из этой программы и не вернется в привычный терминал. Примерами таких интерактивных команд может служить текстовый редактор nano или программа мониторинга системы top.

{% capture notice-2 %}
Выводы:
1. Команды выполняются по принципу REPL (как в IPython, например).
2. В процессе выполнения команды, все что она выведет будет отображаться в терминале.
3. После завершения команды вы опять увидите приглашение. Можно вводить следующую.
4. Пока выполнение команды не закончено, терминал является заблокированным.
5. Существуют интерактивные и неинтерактивные команды.
6. Большинство команд терминала - это стандартные программы из проекта GNU.
7. Если команда ничего не вывела и завершилась - значит все прошло успешно.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Какие приемы работы с командной строкой существуют?


![alt_text](/assets/images/os_text/lx10-6.png "image_tooltip"){: .align-center style="width: 750px;"}


Для успешной и быстрой работы в командной строке существует большое количество сочетаний клавиш. Ознакомьтесь с ними на практике и попробуйте запомнить наиболее полезные:

&lt;Ctrl&gt;+&lt;C&gt; - завершение текущей команды; эта комбинация клавиш используется если вам нужно аварийно прервать выполняющуюся в терминале команду.

&lt;Ctrl&gt;+&lt;D&gt; - выход из текущего сеанса (разлогин); 

&lt;Tab&gt; - подсказки и множественное дополнение; при вводе команды, имени файла не обязательно вводить с клавиатуры название целиком. Можно ввести первые несколько символов и нажать символ табуляции. Если есть только одна команда или один файл с таким именем, оно заполнится автоматически. Если же таких несколько, то при повторном нажатии табуляции вам будет предложены все возможные варианты и вы сможете продолжить ввод с клавиатуры.

clear, &lt;Ctrl&gt; + &lt;L&gt; - очистка экрана (перемотка вперед); можно использовать команду или сочетание клавиш, они работают совершенно идентично.

&lt;↑&gt; - переход к предыдущей команде. Вообще с помощью стрелок вверх и вниз можно перемещаться по истории ранее введенных команд. Это очень экономит время, если вы повторяете команды или изменяете уже введенные.

&lt;Ctrl&gt; + &lt;A&gt; - переход к началу команды; аналогично клавише &lt;Home&gt;.

&lt;Ctrl&gt; + &lt;E&gt; - переход к концу команды; аналогично клавише &lt;End&gt;.

&lt;Alt&gt; + &lt;F&gt;, &lt;Alt&gt; + &lt;B&gt; - переход к следующему и предыдущему слову в команде;

history - вывод истории команд в текущем сеансе;

sudo apt update ; apt upgrade - выполнение нескольких команд из одной строки;

&lt;Ctrl&gt; + &lt;R&gt; - поиск команды в истории; это бывает полезно, если вы уже вводили похожую команду, но не можете ее найти с помощью стрелок. 

Это только самые основные комбинации, работающие в любом терминале Linux. Кроме этого разные оболочки могут вводить собственные сочетания клавиш, сокращения команд и другие фишки для экономии времени. Использование этих возможностей совершенно необязательно, но делает работу в командной строке гораздо быстрее и удобнее. 


### Какова структура команды?


![alt_text](/assets/images/os_text/lx10-7.png "image_tooltip"){: .align-center style="width: 750px;"}


Любая команда оболочки состоит из одной или нескольких частей. Они разделяются пробелами. Основная часть, которая всегда идет первой при вводе команды - ее имя. Имя команды - обязательная часть. Нельзя выполнить команду не зная ее имени. Имя команды- чаще всего это название файла с исполняемым кодом этой команды. Например, ls - это имя команды. Точно так же имена других команд - cp. ps. top. firefox, многие другие.

Некоторые команды вполне обходятся только именем. Уже известная нам команда pwd - это команда, состоящая только из имени. Но у большинства команд кроме имени предусмотрены еще и другие элементы. Ключи или опции - это строки, которые могут быть указаны или отсутствовать и этим каким-то образом модифицировать порядок работы команды. У каждой команды свои опции, но в мире linux есть соглашения о стандартных опциях и их значениях. 

Опции, они же ключи, - это необязательные строки, наличие или отсутствие которых при вызове команды как-то модифицирует ее поведение. Возьмем для примера команду ls. Будучи выполненной без опций она выводит список имен файлов, содержащихся в директории. Но у этой команды есть опция -l. Ее можно указать при вызове команды так: ls -l. То есть опции идут после имени команды через пробел. В таком виде эта команда также выведет список файлов в папке, но уже в табличном виде и с некоторой дополнительной информацией. Еще у команды ls есть опция -a - она заставит команду включить в список скрытые файлы, которые по умолчанию не отображаются. 

Можно заметить, что опции состоят из одной буквы после дефиса. Это так называемый короткий формат опций. Есть еще и длинный. Например, опция -a полностью выглядит как --all. Короткие опции начинаются с одного дефиса и состоят из одной буквы. А длинные - начинаются с двух дефисов и состоят из одного или нескольких слов. Можно написать коротко, а можно и длинно, это одна и та же опция. Естественно, длинными опциями пользуются редко. Но иногда у команды может быть длинная опция, а короткого варианта нет, или наоборот. 

Аргументы есть не у всех команд, указываются обычно после имени и опций. С помощью аргументов можно передать команде какую-то информацию на вход. Примерно так же, как мы передаем аргументы в функцию. Например, у той же команды ls есть необязательный аргумент - имя папки. Без аргументов эта команда отображает содержимое текущей папки, но можно заставить ее отобразить содержимое любой папки указав имя этой папки в качестве аргумента. Например, при вводе команды ls / будет отображены элементы, находящиеся в корневой папке, независимо от того, где мы сейчас находимся. 

Аргументы бывают обязательные и необязательные в предыдущем примере аргумент можно и не указывать. А вот у команды cp есть целых два обязательных аргумента. Без них команда вообще не будет работать. Первый аргумент - это имя копируемого файла, а второй - имя папки, куда мы его копируем. Кроме этого у команды cp есть еще и опции. 

Вообще, у каждой команды свой набор аргументов и опций и правил, в каком порядке нужно их указывать. Это называется синтаксис команды. Синтаксис команды задает разработчик команды при ее создании. Все, что мы описывали ранее - это не более чем набор общепринятых правил, традиционных для стандартных команд Linux. Но помните, что разработчики команд могут и проигнорировать эти правила. Например, в командах операционной системы BSD принято опции делать без дефиса. Поэтому у команды ps опции указываются именно так (ps a, ps aux). Самый лучший способ узнать синтаксис команды - прочитать официальную справку по ней.

{% capture notice-2 %}
Выводы:
1. У любой команды есть имя - название программы - его вводить обязательно.
2. У команды могут быть обязательные или необязательные аргументы и необязательные опции.
3. Опции (ключи) могут модифицировать выполнение программы.
4. Опции бывают длинные и короткие. Короткие начинаются с одного дефиса, длинные - с двух.
5. Опции команды можно комбинировать, а короткие опции можно объединять.
6. Аргументы команды - это как аргументы функции - служат для указания входных данных.
7. Синтаксис команды зависит от ее разработчика и про него можно почитать в справке. 
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Где получить помощь?


![alt_text](/assets/images/os_text/lx10-8.png "image_tooltip"){: .align-center style="width: 750px;"}


При работе с командной строкой приходится постоянно обращаться к документации. Невозможно постоянно держать в голове все команды, нюансы их использования, синтаксис. Поэтому в саму командную строку встроена официальная документация по системным командам. Эта официальная документация называется мануалы, man. Эти мануалы пишут разработчики команд и держат в актуальном виде.

Для доступа к официальным мануалам существует команда man. Есть еще несколько информационных команд (например, info), которые могут различаться от дистрибутива к дистрибутиву. Но man до сих пор остается основным источником информации про синтаксис команд. Посмотреть справку по команде, например, pwd, можно так:


```bash 
$ man pwd
```

Мы получим полную и актуальную справку (мануал) по команде pwd, включая все возможные ее ключи и опции. Команда man может показать мануал по любой команде bash. 

Рекомендуется пользоваться именно этой документацией потому, что синтаксис команд может меняться. В разных дистрибутивах, например, могут быть немного различающиеся наборы стандартных команд. Также синтаксис меняется от версии к версии, с изменением и доработкой самих команд и их окружения. Поэтому именно мануалы покажут вам справку именно по вашей команде именно нужной версии.

Конечно, для того, чтобы почитать мануалы, нужно знать само имя команды. К счастью, мануалы - не единственный источник информации. По всем распространенным командам достаточно легко получить справку и примеры использования в интернете. Существует большое количество тематических справочников, форумов, сообществ пользователей и разработчиков. И чем популярнее дистрибутив вы используете, тем больше про него будет информации. Учебники, справочную литературу тоже не стоит сбрасывать со счетов.

{% capture notice-2 %}
Выводы:
1. Для всех стандартных команд существует официальная справка.
2. Команды и их синтаксис могут меняться в разных дистрибутивах и версиях.
3. Первый источник информации - команда man.
4. Также информацию можно получить в интернете, на форумах, в учебниках.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>
</div>
<h3 id="1-test">Тестирование</h3>
      Пройти <a href="https://campus.fa.ru/mod/quiz/view.php?id=82013">тестирование</a> по этой теме.
  

  
<br/><br/><br/><br/>
<h2 id="Практика: 10 основных команд"> Практика: 10 основных команд</h2>
<p> В этой работе рассматриваются 10 самых частых команд оболочки bash. Вы изучите самые полезные команды работы с файлами и папками. Эти команды обычно составляют до 90% любой работы сисадмина.</p>
<h3 id="2-video">Видео занятия</h3>
<div class="responsive-video-container">
<iframe allowfullscreen="" frameborder="0" mozallowfullscreen="" src="https://www.youtube-nocookie.com/embed/ZccH6NGSHkQ" webkitallowfullscreen="">
</iframe>
</div>
<div>
  ### Практическая работа - десять основных команд Linux


#### Цель работы

Познакомиться с основными приемами работы в командной строке Linux, основные приемы адресации файлов и освоить основные и самые распространенные команды - _pwd, cd, ls, touch, rm, mkdir, cp, mv, cat, man_


#### Задания для выполнения



1. Запустите виртуальную машину; познакомьтесь со справкой к изучаемым в данной работе командам. Обратите внимание на используемые ключи данных команд.
2. Запустите текстовый терминал или программу-эмулятор терминала;
3. Выведите на экран содержимое корневой директории файловой системы;
4. Перейдите в свою домашнюю директорию, задав относительный путь;
5. Выведите содержимое файла /etc/passwd;
6. Создайте текстовый файл с именем user.txt  в домашнем каталоге. 
7. Создайте директорию test в текущей.
8. Переместите только что созданный файл в нее. 
9. Скопируйте директорию под именем test2.
10.  Удалите обе директории. 


#### Методические указания

Для успешного выполнения работы необходимо ознакомиться со справочными материалами по командам _pwd, cd, ls, touch, rm, mkdir, cp, mv, cat_. Сделать это можно используя универсальную справочную команду man. Таким образом, набрав в командной строке:

```bash
$ man pwd
```

мы получим полную и актуальную справку (мануал) по команде pwd, включая все возможные ее ключи и опции. Команда man может показать мануал по любой команде bash.

Некоторые команды завершаются моментально (_pwd_), а другие (_ping_) - выполняются продолжительное время. Кроме того, некоторые команды запускают интерактивные программы (_top_). 

Для успешной и быстрой работы в командной строке существует большое количество сочетаний клавиш. Ознакомьтесь с ними на практике и попробуйте запомнить наиболее полезные:



* &lt;Ctrl&gt;+&lt;C&gt; - завершение текущей команды;
* &lt;Ctrl&gt;+&lt;D&gt; - выход из текущего сеанса (разлогин);
* &lt;Tab&gt; - подсказки и множественное дополнение;
* _clear, &lt;Ctrl&gt; + &lt;L&gt;_ - очистка экрана (перемотка вперед);
* &lt;↑&gt; - переход к предыдущей команде;
* &lt;Ctrl&gt; + &lt;A&gt; - переход к началу команды;
* &lt;Ctrl&gt; + &lt;E&gt; - переход к концу команды;
* &lt;Alt&gt; + &lt;F&gt;, &lt;Alt&gt; + &lt;B&gt; - переход к следующему и предыдущему слову в команде;
* history - вывод истории команд в текущем сеансе;
* &lt;Ctrl&gt; + &lt;R&gt; - поиск команды в истории;

В Linux, как и во многих других Unix-подобных системах принята единая система адресации файлов. Все файлы в Linux имеют имя и организуются в каталоги, образуя иерархическое дерево папок. В данном контексте, мы будем использовать понятия “каталог”, “папка” и “директория” как синонимы. Для того, чтобы идентифицировать файл, вы должны указать путь к нему, то есть порядок вложенности папок, позволяющий найти этот файл.

Все пути в Linux отсчитываются от корня файловой системы, обозначаемого прямым слешем /. Корень всегда один, не существует никаких букв дисков, как в Windows. Корень еще называют корневой папкой или директорией, так как именно в нем содержаться все другие папки. 

В пути к файлу последовательно указываются папки, которые нужно пройти, чтобы найти файл, а затем - имя самого файла. Имена папок и файла разделяются прямым слешем. Так, в пути /etc/passwd первый символ / обозначает корневой каталог, etc - имя папки в корневом каталоге, passwd - имя нужного нам файла. Обратите внимание, что в Linux не принято использовать расширения в именах файлов (но, впрочем, и не запрещено, так что ими многие пользуются). 

Находясь в командной строке, вы всегда находитесь в какой-то директории. По умолчанию, это домашний каталог пользователя (обычно находящийся по адресу /home/&lt;login&gt;). Текущий каталог можно изменить командой cd. 

Путь к файлу можно задавать двумя способами - абсолютным или относительным. Абсолютный путь начинается с символа / и отсчитывается от корневого каталога. Относительный путь начинается с имени папки и отсчитывается от текущего каталога. Это сделано для удобства указания пути, чтобы не повторять одно и то же, если вы работаете в данный момент преимущественно с файлами в одной папке. 

При указании путей к файлам можно пользоваться некоторыми сокращениями. Вы можете использовать два специальных имени: точку (.), означающую текущую директорию, и пару точек (..), означающую родительскую директорию текущей директории. Также вы можете использовать символ тильды (~), который означает вашу домашнюю директорию, и сочетание ~username, означающее домашнюю директорию пользователя с именем username.

Помните, что нужно четко представлять себе, где лежит тот или иной файл для того, чтобы с ним работать. Часто /etc/passwd и etc/passwd - это два совершенно разных файла в разных местах.


#### Контрольные вопросы



1. Как происходит авторизация пользователя в текстовом режиме?
2. Как посмотреть рабочую директорию?
3. Как посмотреть содержимое текущей директории?
4. Чем отличается абсолютный и относительные пути к директориям?
5. Как перейти в другую директорию в командной строке?
6. Какие основные стандартные каталоги существуют в Linux?


#### Дополнительные задания



1. Выяснить, какой каталог является текущим (см. man pwd).
2. Выяснить, в каком терминале выполняется текущий сеанс.
3. Перейдите в директорию /var;
4. С помощью команды узнайте, в какой директории находимся;
5. Прочитайте мануал по команде ls (только основное положение и про флаги -l, -t, -r, -A);
6. Отобразите список директорий и файлов;
7. Перейдите в директорию /var/log (без упоминания “var” в команде);
8. Перейдите в директорию /var (снова без упоминания “var”);
9. Создайте директорию ~/tmp/lesson/;
10. Перейдите туда, задав абсолютный путь;
11. Создайте текстовый файл txt_file с произвольным содержимым;
12. Удалите созданную папку lesson;
13.  Сохраните подробное описание полного содержимого домашней директории (по команде ls -la) в файл home.dir.
14. (*) Определить границы файлового пространства, где система позволяет создавать собственные файлы и каталоги (возможно использование автоматического скрипта).
15. (*) Проверить, возможно ли вмешательство  в личное файловое пространство другого пользователя? Пользователя root?
</div>
<br/><br/><br/><br/>
<h2 id="Практика: Служебные команды"> Практика: Служебные команды</h2>
<h3 id="3-video">Видео занятия</h3>
<div class="responsive-video-container">
<iframe allowfullscreen="" frameborder="0" mozallowfullscreen="" src="https://www.youtube-nocookie.com/embed/B7EG9nsSvNk" webkitallowfullscreen="">
</iframe>
</div>
<div>
  ### Практическая работа - служебные команды терминала


#### Цель работы

Научиться основным навыкам работы в многопользовательском режиме, переключению между терминалами и самым базовым командам - _tty, who, whoami, sudo, su, less, who, exit, shutdown, grep_.


#### Задания к работе



1. Откройте первый виртуальный терминал и залогиньтесь.
2. Выполните команду tty.
3. Выполните команду pwd.
4. Повторите предыдущие пункты для второго и третьего виртуального терминала.
5. Откройте эмулятор терминала в графическом режиме и введите команду tty.
6. Выполните команду who. Посмотрите в справке, что она показывает.
7. Выполните команду whoami. Прочитайте справку про нее. 
8. Перейдите в первый виртуальный терминал и разлогиньтесь.
9. Вернитесь в графическое окружение и еще раз просмотрите вывод команды who. Объясните ее результат.
10.  Откройте файл /etc/passwd при помощи программы-пейджера.
11. Найдите в этом файле запись о вашем текущем пользователе при помощи команды grep.
12. Изучите команду man и прочитайте справку по всем командам, использованным в данной лабораторной.


#### Методические указания

Операционная система Linux, как и ее предшественник - UNIX изначально создавалась для многопользовательской работы. Для организации многопользовательской работы при загрузки системы создается семь виртуальных устройств (это число может меняться в зависимости от дистрибутива, но семь - это стандартное количество). Раньше предполагалось, что за ними будут работать из разных мест при помощи оконечных устройств (терминалов или тонких клиентов), но сейчас это уже не очень актуально. Обычно на последнем, седьмом терминале запускается графическая оболочка, если она установлена в данном дистрибутиве.

Для того, чтобы узнать, номер текущего терминала, можно использовать команду tty (см. man tty). Команда очень проста и не требует параметров. Пример работы tty:


```bash
$ tty  
/dev/tty1
```

Чтобы узнать, какие пользователи в каких терминалах залогинены в системе, можно использовать команду who:

```bash
$ who 
root tty1 Feb 17 17:11 
user tty2 Feb 17 17:12 
user tty5 Feb 17 17:40
```

Иногда возникает необходимость выполнить некоторые действия от имени другого пользователя (например, от имени root). Это можно сделать, открыв новый терминальный сеанс, но можно и иначе, в текущем сеансе. Для этого используется команда su. Эта команда по умолчанию (без параметров) открывает сеанс суперпользователя, выполняющийся внутри сеанса непривилегированного пользователя. Пример выполнения команды su:


```bash
$ su 
Password: 
[root@localhost user]#
```

Еще один пример, с явным указанием имени пользователя:


```bash
$ su stud 
Password:  
[stud@localhost ~]$
```

Для окончания пользовательского сеанса, запущенного командой su, или выхода из терминала, используется команда exit или комбинация клавиш Ctrl+D. В любом случае система закроет сеанс и отобразит строку приглашения.

Очень часто при работе с командной строкой приходится просматривать довольно длинные файлы. Для того, чтобы можно было перемещаться по файлу, содержимое которого не помещается на одном экране были созданы специальные программы-пейджеры. Это не текстовый редактор, а только средство просмотра. Самый стандартный на сегодня - программа less. Ей можно передать имя файла таким образом:


```bash
$ less filename
```

Познакомьтесь с ней, прочитав интерактивную справку. Для того, чтобы закрыть ее необходимо нажать кнопку q. 

Также часто приходится искать определенную строку в файле или в выводе других команд. Для этого используют утилиту grep. Ей передаётся два параметра - строка поиска и имя файла вот так:


```bash
grep koroteev /etc/passwd
```

Дополнительная информация об указанных командах доступна в справочном руководстве формата man или info.

Еще одно важное замечание. При работе с эмулятором терминала в графическом режиме, копирование и вставка работают с комбинациями клавиш Ctrl + Shift+C и Ctrl + Shift+V. Это потому, что комбинацией клавиш Ctrl + C аварийно завершается (прерывается) выполнение текущей команды.


#### Контрольные вопросы



1. Какой каталог будет установлен текущим сразу же после входа пользователя в систему?
2. Какой каталог будет установлен текущим после выполнения команды su?
3. Какой терминал (tty) будет открыт по нажатию Ctrl+F7?
4. Как и где в Linux можно вводить команды командной строки?


#### Дополнительные задания



1. Подключитесь к данной машине через ssh и введите команду who. Объясните, что значит ее результат.
2. Загрузить систему в текстовом режиме и войти с собственной учетной записью
3. Ознакомиться со справкой по команде shutdown;
4. С её помощью перезагрузить виртуальную машину;
5. С её помощью выключить виртуальную машину;
6. Запустить отложенное выключение виртуальной машины на 2 минуты.
</div>
<br/><br/><br/><br/>
<h2 id="Лекция: Работа с файлами"> Лекция: Работа с файлами</h2>
<p> </p>
<h3 id="4-slides">Презентация</h3>
      Смотреть <a href="/pres/os11-3/">слайды</a> к этому занятию.
  

      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
<div>
  ### Как организована структура каталогов Linux?

![styled-image](/assets/images/os_text/lx13-1.png "Linux directory structure"){: .align-center style="width: 800px;"}

Одно из самых базовых понятий для любой операционной системы - это файл. Обычно, мы подразумеваем под файлом некоторое количество информации, хранящееся в постоянном хранилище (на диске), имеющее имя. Однако, Linux построена таким образом, что практически любой объект, с которым работает операционная система является файлом. Привычные нам файлы здесь называются обычными, но кроме них еще существует несколько типов, которые Linux также называет файлами, хотя с точки зрения обывателя они воспринимаются как что-то другое. Например, любое физическое устройство имеет в операционной системе особое логическое представление в виде файла в определенной папке. Вы можете зайти в эту папку и просмотреть список устройств, зайти в конкретный файл и увидеть свойства этого устройства. Однако это не просто статическая информация, хранящиеся на диске. Это динамический объект операционной системы, на диске он не занимает никакого места, его там нет. При обращении к этому файлу происходит вызов особых функция ядра ОС. Кроме этого для Linux папки, ссылки (аналог ярлыков), даже процессы самой ОС - тоже файлы. 

Это сделано для унификации доступа к различным ресурсам операционной системы. Зачем придумывать особый механизм отправки документов на печать, если можно просто записать текст в файл принтера. Такой подход может немного запутывать сначала, но довольно быстро привыкаешь, что для Linux практически любой объект - это файл. Но довольно часто приходится оговариваться, имеется в виду файл в узком смысле, обычный файл, как информация на диске с именем, или в широком смысле, как концепция операционной системы.

Понятно, что файлов в каждой отдельно взятой операционной системе может быть огромное количество. И только малая часть из этого - файлы пользователей. Кроме этого существуют служебные файлы операционной системы, конфигурационные файлы, файлы системных и прикладных программ, псевдофайлы, которые мы обсуждали ранее. Если бы файлы имели только имя, ориентироваться в этой куче было бы решительно невозможно. Для этого и нужны папки. Папки, они же директории или каталоги, служат для объединения произвольного количества файлов во множество в некоторым именем. Неудивительно, что для Linux папка - это тоже файл, его особый тип. Фактически, папка - это файл, содержащий список других файлов, которые в считаются “в этой папке”. Так что сами папки тоже можно “класть” в другие папки. Таким образом, структура файлов и папок образует иерархическую структуру-  дерево файловой системы. 

А что происходит с файлами и папками, которые не  находятся в других папках? В Linux существует специальная корневая папка. Она обозначается прямым слешем (/). Она является вершиной этой иерархии, корнем дерева, единой точкой отсчета для всех других папок на данном компьютере. Так что любой файл находится в какой-то папке, либо в в корневой директории, либо в каком-то каталоге, который может быть в другом каталоге, и так далее, но в итоге все равно в корневой папке.

Таким образом, для того чтобы указать на какой-то конкретный файл нам недостаточно его имени, еще нужен его “адрес” - путь от корневой директории по (возможно нескольким) вложенным папкам до самого файла. Такой адрес называется “путь” к файлу. У каждого файла, который находится в операционной системе существует один и только один абсолютный путь от корневой директории. Заметьте, кстати, что конкретный файл не может находится в нескольких разных папках одновременно, то есть в двух местах сразу.

Все пути в Linux отсчитываются от корня файловой системы, обозначаемого прямым слешем /. Корень всегда один, не существует никаких букв дисков, как в Windows. Корень еще называют корневой папкой или директорией, так как именно в нем содержаться все другие папки. В пути к файлу последовательно указываются папки, которые нужно пройти, чтобы найти файл, а затем - имя самого файла. Имена папок и файла разделяются прямым слешем. Так, в пути /etc/passwd первый символ / обозначает корневой каталог, etc - имя папки в корневом каталоге, passwd - имя нужного нам файла. Обратите внимание, что в Linux не принято использовать расширения в именах файлов (но, впрочем, и не запрещено, так что ими многие пользуются). 

В корневой папке обычно не хранятся обычный файлы, только папки. Причем папки корневой директории несут особую смысловую нагрузку. Например, каталог /etc/ хранит текстовые конфигурационные файлы самой операционной системы, а каталог /dev/ - те самые псевдофайлы-устройства, о которых мы уже упоминали. Этот набор стандартных папок немного меняется от дистрибутива к дистрибутиву, но основные остаются общими. Существует даже специальный стандарт - Lnux FHS (filesystem hierarchy standard), который и описывает набор и предназначение стандартных папок корневой директории.

{% capture notice-2 %}
Выводы:
1. Для Linux практически любой объект - файл.
2. В Linux файлы организованы привычным образом в папки и подпапки, образуя иерархическую структуру - дерево файловой системы.
3. Корневая папка / - это единая точка отсчета для всех папок.
4. Каждый файл имеет один и только один адрес в файловой системе - абсолютный путь к нему.
5. Для разделения имен папок и файлов в Linux используется только прямой слеш.
6. В Linux принята стандартная структура файлов.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое относительные и абсолютные пути?

Для того, чтобы операционная система, программы и пользователи могли работать с файлами и обращаться к ним у каждого файла должен быть уникальный идентификатор. Но просто имени недостаточно, потому что могут существовать несколько файлов с одинаковыми именами. Поэтому операционная система обращается к файлам используя пути.

Путь к файлу можно задавать двумя способами - абсолютным или относительным. Абсолютный путь начинается с символа / и отсчитывается от корневого каталога. Относительный путь начинается с имени папки и отсчитывается от текущего каталога. Это сделано для удобства указания пути, чтобы не повторять одно и то же, если вы работаете в данный момент преимущественно с файлами в одной папке. 

При указании путей к файлам можно пользоваться некоторыми сокращениями. Вы можете использовать два специальных имени: точку (.), означающую текущую директорию, и пару точек (..), означающую родительскую директорию текущей директории. Также вы можете использовать символ тильды (~), который означает вашу домашнюю директорию, и сочетание ~username, означающее домашнюю директорию пользователя с именем username.

Помните, что нужно четко представлять себе, где лежит тот или иной файл для того, чтобы с ним работать. Часто /etc/passwd и etc/passwd - это два совершенно разных файла в разных местах. Поэтому нужно всегда четко представлять себе расположение нужного вам файла относительно текущей директории и использовать относительные или абсолютные пути правильно, не путая их.

Может показаться, что для простоты и надежности следует всегда использовать абсолютные пути. Однако относительный формат был придуман не просто так. С одной стороны, он добавляет удобства и скорости работы в командной строке, так как абсолютные пути могут быть очень длинными и в них легко ошибиться ил опечататься. Именно для этого придумано понятие текущей папки - это просто название папки, которое автоматически поставляется в относительные пути, чтобы получить абсолютный. 

Но у относительных путей есть и еще одно применение. Представьте, что вы пишите скрипт или программу, которая работает с файлами в какой-то своей папке. У рабочей папки программы может быть разное расположение на разных компьютерах, или оно может поменяться если вы просто перенесете программу в другое место. Если вы используете абсолютные пути, то при каждом таком переносе программа просто сломается. То есть абсолютные пути слишком зависят от положения точки отсчета и делают программу непереносимой. Использование же относительных путей решает эту проблему - при переносе программы в другое место вся внутренняя структура папок сохранится и программа будет работать корректно без необходимости менять исходный код.

{% capture notice-2 %}
Выводы:
1. У каждого файла в системе есть один уникальный адрес.
2. Следует различать абсолютные и относительные пути к файлам.
3. Абсолютный путь отсчитывается от корня файловой системы и не зависит от того, где находится пользователь.
4. Относительный путь отсчитывается от текущей директории пользователя.
5. Смысл переходить по директориям как раз в том, чтобы относительные пути были короче.
6. Лучше использовать относительные пути в программах и скриптах для переносимости. 
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Какие виды файлов существуют?

![styled-image](/assets/images/os_text/lx13-2.png "Linux file types"){: .align-center style="width: 800px;"}

Мы уже говорили раньше, что UNIX-подобные операционные системы представляют многие разные объекты, с которыми приходится работать в виде файлов. Это удобно и для операционной системы и для пользователей. Давайте кратко перечислим основные виды файлов и их зачем они нужны. Посмотреть тип файла всегда можно командой ls -l. В строке соответствующей файлу самый первый символ, один из атрибутов файла, указывает его тип.

Обратите внимание, что тип файла - это не расширение, как в Windows. Там расширение является обязательным элементом имени файла и показывает операционной системе, какой программой его нужно “открывать”, то есть обрабатывать его содержимое. Другими словами, расширение файла характеризует характер содержимого этого файла. В UNIX принята другая система. Изначально вы запускаете программы командами в терминале, то есть явно указываете название программы, которая должна запуститься и обрабатывать тот или иной файл. Поэтому расширение для операционной системы необязательно. Но с распространением графических интерфейсов, когда пользователи привыкают открывать файл щелчком мыши, практика использования расширений в именах файлов начинает распространяться и на Linux. Так почти все графические окружения поддерживают ассоциации файлов с программами через расширения, как в Windows. Кроме того, это удобно пользователю, так как глядя на имя файла он может предположить, что за информация там хранится.

Самый простой тип файла так и называется - обычный файл. Он помечается символом дефиса (-). Это именованная область данных на носителе, которая может содержать произвольную информацию. Часто чтобы не путаться этот тип файлов называется документом, хотя в Linux к обычным файлам относятся и мультимедийные, и офисные, и исполняемые файлы программ и файлы с исходным текстом программ и скриптов. Короче говоря, все, что в Windows называется файлом, в Linux - обычный файл.

Мы уже говорили, что папки в UNIX - это тоже файлы. Это второй по распространенности тип файлов - папки, директории или каталоги. Это все разные названия одного и того же. Они служат для организации файлов и упрощения навигации по файловой системе. В Linux папки - это по сути просто специальный файл, который содержит список других файлов, которые считаются “лежащими” в этой папке. Файл типа каталога помещается символом d.

Еще один тип файлов - это ссылки. Они помечаются символом l (link). Ссылки вместо пользовательских данных содержат путь к другому файлу. Именно этот файл будет открываться при обращении к ссылке. Этот механизм работает аналогично ярлыкам в Windows. Ссылки нужны для более удобной организации файлов, иногда бывает полезно иметь доступ к одному и тому же файлу из разных мест, то есть папок. Можно, конечно, файл просто скопировать, но копирование файлов расходует место на диске и при изменении одной копии вторая останется старой. Надо понимать, что при удалении или перемещении исходного файла все ссылки на него, если такие есть, перестанут работать. Такие ссылки называются битыми.

Надо сказать, что все это относится к так называемым символическим, или мягким ссылкам. Именно они работают подобно ярлыкам. Но в Linux есть и другой тип ссылок - жесткие ссылки. Жесткие ссылки работают совершенно по-другому и на другом уровне. По сути дела - это просто другое имя одного и того же файла. Любой файл имеет как минимум одну жесткую ссылку на него - это само имя файла. Но вы можете создать новую ссылку. И для операционной системы все жесткие ссылки на файл являются равноправными, в отличие от символических, где есть сам файл и ссылки на него. Даже если вы удалите файл по первоначальному имени, если на него есть еще жесткие ссылки, он проложит существовать. Файл удаляется тогда, когда перестает существовать последняя жесткая ссылка на него.

Еще один тип файлов в UNIX - это специальные файлы устройств. Их можно распознать по символу c или b в атрибутах. 

{% capture notice-2 %}
Выводы:
1. Обычные файлы содержат информацию в виде данных или программного кода.
2. В Linux тип файла - это не расширение, они вообще не обязательны.
3. Директории, каталоги или папки - это список файлов.
4. Ссылки используются для удобства нахождения файла в нескольких папках одновременно.
5. Символические ссылки - это как ярлыки в Windows.
6. Жесткие ссылки - это два адреса одного и того же файла.
7. Сокеты используются для взаимодействия между процессами.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как работать со ссылками в консоли?

Самые распространенные операции с обычными файлами и каталогами мы уже изучали ранее. Сейчас поговорим о более специфичном для Linux явлении - ссылках. Для того, чтобы поглубже понять, как работают ссылки, нам надо сначала разобраться, что такое inode.

inode – это объект файловой системы, содержащий информацию о владельце/группе, которым принадлежит файл или каталог, его права доступа к нему, его размер, тип файла, timestamp-ы отражающие время модификации индексного дескриптора (ctime, changing time), время модификации содержимого файла (mtime, modification time) и время последнего доступа к файлу (atime, access time) и счётчик для учёта количества жёстких ссылок на файл. Каждый inode имеет собственный номер, который присваивается ему файловой системой в момент её создания (форматирования). По сути, inode - это уникальный численный идентификатор файла в файловой системе. Узнать inode обычному пользователю не требуется, но если интересно, можно воспользоваться опцией -i команды ls:

![Inodes](/assets/images/os_text/lx13-3.png "Inodes"){: .align-center style="width: 800px;"}

Иногда может возникнуть “странная” ситуация: с одной стороны – df или du будут говорить, что свободное место на диске есть, а с другой стороны операционная система будет утверждать, что “No Space Left on Device”. Одна из вероятных причин как раз явлется полное использование пула inode, выделенных для раздела на жёстком диске, т.к. кол-во inode фиксировано и задаётся во время создания таблицы раздела. Проверить общее, занятое и доступное количество inode можно с помощью df и опции -i:

![Inode availability](/assets/images/os_text/lx13-4.png "Inode availability"){: .align-center style="width: 800px;"}

Создать жесткую ссылку на файл можно командой ln. синтаксис команду такой:

```bash
$ ln целевой_файл файл_ссылка
```
при этом можно создать ссылку как на файл из этой же папки, так и на любой другой. Для этого надо воспользоваться относительными или абсолютными путями к файлу.

![Hard link creation](/assets/images/os_text/lx13-5.png "Hard link creation"){: .align-center style="width: 800px;"}

Кстати, вы не можете создать жесткую ссылку на файл, к которому у вас нет доступа на запись, ведь формально вы вносите изменение в inode. А для этого вы должны обладать соответствующими правами.

Обратите внимание, что у исходного файла и у ссылки - один и тот же inode. То есть по сути для операционной системы это один и тот же файл с двумя разными именами. Кстати, даже изначальный файл строго говоря - это жесткая ссылка на свой собственный  inode. Поэтому жесткая ссылка - это не как ярлык к файлу, это именно два разных имени одного и того же файла.

![Hard link deletion](/assets/images/os_text/lx13-6.png "Hard link deletion"){: .align-center style="width: 800px;"}

Поэтому при удалении исходного файла жесткая ссылка на него никуда не девается и даже продолжает работать. Сам файл, то есть inode, удалится только тогда, когда на него будет удалена последняя жесткая ссылка. Именно для этого у каждого файла отслеживается количество жестких ссылок на него. Это число вы можете видеть в подробном выводе команды ls после прав доступа и перед ником владельца файла.

![Symlink](/assets/images/os_text/lx13-7.png "Symlink"){: .align-center style="width: 800px;"}

А вот символические ссылки, symlink'и, работают именно как ярлыки Windows, то есть как указатели на файл. Создать символическую ссылку можно командой 

```bash
$ ln -s целевой_файл файл_ссылка
```

В терминале символические ссылки отображаются по -другому. Во-первых, обратите внимание на тип файла. Это уже символ 'l' - то есть ссылка. Во-вторых, inode изначального файла и ссылки отличаются. И в-третьих после имени ссылки указывается имя файла, на который она ссылается. Причем, если удалить исходный файл, ссылка перестанет работать. Она станет так называемой "битой ссылкой", то есть ссылкой, которая никуда не ведет. В терминале с цветовой подсветкой такие ссылки дополнительно отображаются красным цветом для привлечения внимания.

{% capture notice-2 %}
Выводы:
1. Создание, удаление, копирование, перемещение файлов изучалось ранее.
1. inode - это уникальный численный идентификатор файла в файловой системе.
1. inodes могут закончиться на разделе жесткого диска, тогда вы не сможете создать файл, даже если места для него хватает.
2. Создать жесткую ссылку на файл можно командой ln.
3. Файл существует до тех пор, пока на него есть хотя бы одна жесткая ссылка.
4. Создать символическую ссылку на файл можно командой ln -s.
5. Если удалить символическую ссылку исходный файл останется нетронутым.
6. Если удалить сам файл, то все символические ссылки на него станут недействующими.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Что такое перенаправление ввода-вывода?

Как мы уже говорили, все консольные команды Linux являются текстоцентричными - они принимают на вход текстовый поток и выдают в качестве результата тоже какой-то текстовый поток. Текстовый поток - это по сути, одна или несколько строк текстовой информации, которая читается последовательно. Текстовые потоки очень похожи на текстовые файлы - у них есть начало, определенный конец. Но в отличие от файлов потоки читаются только последовательно, символ за символом, пока не будет достигнут специальный символ, обозначающий конец потока.

У любого процесса в операционной системе Linux существует три стандартных текстовых потока, ассоциированных с ним. Они создаются и связываются в процессом самой операционной системой. Поэтому они называются стандартными потоками. Это все справедливо, в частности, для всех команд терминала.

Стандартный поток ввода (STDIN) при работе пользователя в терминале связывается с клавиатурой. При работе команды она может считать текст их с STDIN. в таком случае выполнение команды приостанавливается и она ждет ввода пользователем текста в терминале, в котором выполняется команда. Когда пользователь введет текст и нажмет <enter>, либо <ctrl>+<d> (окончание текстового потока), введенный текст передается в команду.

Стандартный поток вывода (STDOUT) предназначен для отображения результата работы программы. Он по умолчанию связывается с терминалом, в котором она выполняется. Если программа посылает какой-то текст на свой STDOUT (в Python для этого существует оператор print, в bash - его аналог echo), пользователь видит его в терминале.

Стандартный поток ошибок (STDERR) работает аналогично STDOUT, но предназначен для вывода сообщений об ошибках, возникающих в процессе работы программы. По умолчанию он так же выводится в терминал, но по желанию программы или пользователя его можно перенаправить отдельно от обычного стандартного потока вывода.

В процессе своей работы команда или программа может открывать дополнительные потоки, например, открыв сетевое соединение или файл на чтение или запись. Но три стандартных потока существуют всегда. Большинство стандартных программ и команд Linux устроены таким образом, что все необходимые для своей работы данные они должны считывать с STDIN, на все результаты совей работы записывать в STDOUT. Таким образом программа представляет собой такой черный ящик в одним входом и одним выходом. Это очень полезное и распространенное соглашение по проектированию текстовых программ Linux, которое позволяет их объединять.

Потоки ввода-вывода можно перенаправлять и подключать к чему угодно: к файлам, программам или даже устройствам. Эта возможность очень мощная и полезная в определенных условиях. При помощи перенаправления потоков можно использовать программы и команды Linux гораздо более удобным и коротким образом. Перенаправления ввода-вывода осуществляются при помощи специальных обозначений, которые обычно указываются после команды, ввод или вывод которой вы хотите перенаправить. Существует несколько вариантов такого перенаправления:

* &lt; file — использовать файл как источник данных для стандартного потока ввода.
* \&gt; file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
* 2\&gt; file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — перезаписан сверху.
* \&gt;\&gt;file — направить стандартный поток вывода в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
* 2\&gt;\&gt;file — направить стандартный поток ошибок в файл. Если файл не существует, он будет создан, если существует — данные будут дописаны к нему в конец.
* &amp;\&gt;file или \&gt;&amp;file — направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: \&gt;file 2\&gt;&amp;1.

Давайте рассмотрим наиболее распространенные сценарии такого перенаправления.

Возьмем для примера программу cat. Она считывает один ил несколько файлов, переданных ей как аргументы и выводит их содержимое (если файлов несколько, то она "склеит", конкатенирует их содержимое, отсюда и название команды) на свой STDOUT. При помощи символа \&gt; после команды можно перенаправить ее STDOUT в другое место, например, в файл. Таким образом, если выполнить команду:

```bash
$ cat file1 file1 file1 &gt; bigfile
```
то вместо вывода содержимого файлов на экран, в терминал, команда cat запишет этот текстовый поток в файл bigfile. То есть эта команда объединит содержимое нескольких файлов в один. Таким же способом можно записать в файл результат работы любой команды.

Обратите внимание, что при использовании символа \&gt; если целевой файл уже существует, то он будет перезаписан. Если вам нужно добавить информацию в существующий файл, то следует использовать оператор \&gt;\&gt;. Он имеет такой же эффект, но всегда добавляет новый текстовый поток в конец файла. Если же файла нет, то эти два оператора работают идентично.

Аналогично работает и перенаправление из файла. Например, существует команда sort, которая сортирует строки из текстового потока по алфавиту. По умолчанию, эта команда принимает текст для сортировки из своего STDIN, но в нее можно направить файл вот так:

```bash
$ sort <domains.list apt="" install="" linux="" tmux=""> /dev/null
```

Надо сказать, что операторы \&gt;, \&gt;\&gt; и &lt; работают только, когда с одной стороны команда, а с другой - файл (или псеводустройство). но можно и объединять команды - то есть перенаправлять вывод одной команды на ввод другой. Такая операция называется конвейером (pipe) и обозначается оператором \|. Например, таким образом какой-то очень длинный вывод можно подать на вход программе-пейджеру, которая отобразит его с возможностью перелистывания:

```bash
$ ls | less
```

Операции перенаправления и/или конвейеры могут комбинироваться в одной командной строке.

``` bash
$ command <input-file>output-file
```

```bash
$ command1 | command2 | command3 &gt;output-file
````

{% capture notice-2 %}
Выводы:
1. Линуксовые команды работают с текстовым вводом и текстовым выводом.
1. У каждого процесса есть три стандартных текстовых потока - ввод, вывод и поток ошибок.
1. Можно перенаправить результат команды в файл при помощи &gt; или \&gt;\&gt;.
1. Можно направить содержимое файла на вход команде при помощи &lt;.
1. Объединять команды можно при помощи конвейера \|.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как работать с архивами?

При работе с файлами и папками часто возникает задача работы с архивами. Архив - это файл, который содержит в сжатом виде несколько файлов или папок. Архивы - это удобный способ хранения и обмена информацией. Существует большое количество алгоритмов архивации данных, множество программ-архиваторов и, соответственно, множество форматов архивных файлов. Пользователи Windows, больше всего знакомы с архивами .zip или .rar. 

В Linux тоже существуют много программ-архиваторов, но самыми распространенными являются zip, tar и gzip. Самая простая и понятная программа, которую мы советуем новичкам - это zip. Она имеется в большинстве пользовательских дистрибутивов, проста по синтаксису, работает с самым распространенным форматом архивов.

Команда 

``` bash
$ zip archive.zip file1
```

сжимает файл в архив. При помощи команды zip archive.zip * можно сжать в архив всю папку.

Разархивация такого архива осуществляется командой unzip:

``` bash
$ unzip archive.zip 
```

С помощью опции -d можно указать другую папку, куда будет распаковано содержимое архива. Кроме того, вторым аргументом можно указать конкретный файл, который должен быть извлечен из архива.

Кроме формата zip, пользователи Linux могут встретиться с архивами формата .tar. Обычно они имеют двойной расширение - .tar.gz или .tar.bzip2. Это архивы, созданные программой tar - классической командой Linux. Особенностью этой программы является то, что она умеет создавать и распаковывать архивы, но не умеет их сжимать. Поэтому для сжатия используются другие инструменты - программы zip, gzip или bzip2.

Если вы встретили такой архив, то его можно распаковать командой: 

``` bash
$ tar -xvf file.tar.gz
```

У этой команды почти всегда много опций. x означает распаковку архива, v - вывод подробной информации о процессе (необязательно), f - указание файла для распаковки.

{% capture notice-2 %}
Выводы:
1. Команда zip archive.zip file1 сжимает файл в архив.
3. Команда zip archive.zip * сжимает в архив все файлы из текущей директории.
4. Команда zip -r archive.zip directory1 directory2 directory3 позволяет сделать архив из папок.
5. Команда unzip -l file.zip показывает содержимое архива.
5. Команда unzip file1.zip распаковывает архив.
5. Команда unzip file1.zip -d folder/ распаковывает архив в определенную папку.
5. Команда unzip file1.zip file извлекает файл из архива.
1. Команда tar -xvf archive.tar распаковывает архив в текущую директорию.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как найти нужный файл?

При работе в командной строке очень часто возникает задача найти файл или информацию. Специально для этого существует очень мощная команда find - одна из самых часто используемых команд терминала. find - это стандартная команда, ее не надо устанавливать отдельно, она присутствует во всех дистрибутивах Linux. 

Общий синтаксис команды find выглядит так:

``` bash
$ find [папка] [критерий] [действие]
```
 Первым параметром всегда идет папка, в которой будет производиться поиск. Если ее не указать, то команда будет искать файлы в текущей папке. 

С помощью критериев можно задать особые условия поиска. Так, критерий -name осуществляет поиск по имени файла. Причем в имени можно задать шаблон. Например, такая команда будет искать все файлы с расширением txt:

``` bash
$ find . -name"*.txt"
```

Критерий -type позволяет искать файлы по типу, которые бывают следующих видов:


* f – простые файлы;
* d – каталоги;
* l – символические ссылки;
* b – блочные устройства (dev);
* c – символьные устройства (dev);
* p – именованные каналы;
* s – сокеты;

Например, указав критерий -type d будут перечислены только каталоги.

Довольно полезен критерий size, который задает размер файла. Можно искать файлы больше или меньше указанного размера с помощью символов + или -, либо по точному размеру, например так:

``` bash
$ find . size +1G
```

Кроме того, другие критерии этой команды позволяют искать файлы по владельцу, по времени модификации, времени доступа, задавать глубину поиска по подкаталогам, игнорировать регистр, и еще много чего. Для полного знакомства с этой командой рекомендуется прочитать мануал по ней для вашего дистрибутива. 

{% capture notice-2 %}
Выводы:
1. Для поиска файлов в Linux удобнее всего использовать команду find.
1. Пример использования: find /home/ -size +1000000k
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>


### Как сделать резервную копию?

Одна из самых типичных задач администратора операционной системы - резервное копирование информации (бекап). Оно позволяет застраховаться на случай аппаратных или программных сбоев, ведь именно информация - это самое ценное, что существует в компьютерных системах. Но вообще, резервным копированием нужно заниматься и обычным пользователям, ведь у вас тоже может быть важная информация, которую не хотелось бы потерять. Особенно важно производить бекапы в условиях изменений информационной среды - обновлении программ и операционной системы, миграции на новые версии программ, в ходе разработки программного обеспечения, при развертывании рабочих и тестовых сред.

Rsync (Remote Sync) — это наиболее часто используемая команда для удаленного и локального копирования и синхронизации файлов и каталогов в системах Linux/Unix. С помощью команды rsync вы можете удаленно и локально копировать и синхронизировать данные между каталогами, дисками и сетевыми хранилищами, выполнять резервное копирование данных.

Программа rsync не всегда поставляется вместе с дистрибутивом, поэтому проверьте, есть ли она у вас. Если у вас команда rsync выдает сообщение о том, что программа не найдена, то вам надо установить ее командой:

```bash
$ sudo apt install rsync
```
Базовый синтаксис программы rsync выглядит так:

```bash
$ rsync options source destination
```

source и destination - это названия файлов или папок, соответственно, откуда и куда будет произведено копирование. Обычно происходит копирование из какой-то папки в папку или файл на другом разделе жесткого диска, даже на другой машине, по сети.

Как у любой мощной команды, у rsync большое количество опций. Перечисли самые полезные:

* -v: подробный вывод.
* -r: рекурсивно копирует данные (но не сохраняет временные метки и разрешения при передаче данных).
* -a: режим архива, позволяет рекурсивно копировать файлы, а также сохраняет символические ссылки, права доступа к файлам, права владения пользователей и групп и временные метки.
* -z: сжатие данных в ходе копирования.
* -h: вывод информации о ходе копирования

Основной особенностью команды rsync по сравнению с обычным копированием является то, что она копирует данные инкрементально. То есть, если в месте назначения уже была более старая резервная копия, то rsync будет копировать только разницу, то есть то, что изменилось с последнего бекапа. Это позволяет сильно экономить на времени и ширине канала копирования, особенно, если вы делаете бекапы часто.

Кроме локального копирования, rsync позволяет так же просто делать бекапы по сети с или на удаленный хост. Для этого, он должен быть доступен по сети, мы должны знать его адрес (обычно, IP-адрес или доменное имя), а так же иметь учетные данные (то есть знать имя пользователя и его пароль на удаленной машине). Указать удаленную машину можно, например, так:

```bash
$ rsync -avz rpmpkgs/ root@192.168.0.100:/home/
```

Перед началом копирования команда попросит вас ввести пароль. Подключение может проходить по протоколу защищенного соединения SSH, тогда данные еще и шифруются при передаче.

Rsync, как и многие сетевые программы является клиент-серверной программой. Это значит, что для успешного общения двух машин по протоколу rsync необходимо, чтобы эта программа была установлена на обоих машинах. Более того, на удаленном компьютере должен быть настроен сервер rsync, то есть разрешены сетевые подключения к этой программе. 

Для этого нужно создать файл настроек /etc/rsyncd.conf (создание файлов в системной папке /etc/ доступно только пользователю root) с примерно таким содержанием:

```
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsync.log
[share]
path = /tmp/share/
hosts allow = 192.168.56.1
hosts deny = *
list = true
uid = root
gid = root
read only = false
```

В этом файле мы для безопасности разрешаем удаленный доступ к данному компьютеру через rsync только с одного IP-адреса - 192.168.56.1. Вам, конечно, нужно прописать адрес той машины, с которой вы будете запускать бекапы.

После создания конфигурационного файла необходимо запустит сервер и добавить его в автозагрузку.

```bash
$ sudo systemctl start rsync
$ sudo systemctl enable rsync
```

Если эти две команды выполнились без ошибок, это значит, что можно пользоваться службой rsync для удаленного резервного копирования.

{% capture notice-2 %}
Выводы:
1. Программа Rsync используется для инкрементального резервного копирования.
2. Команда rsync -avr /source/ /destination/ копирует содержимое одной папки в другую.
3. Rsync позволяет копировать с или на удаленный хост используя протокол SSH.
4. Синхронизация с удаленным хостом выполняется командой rsync -avz /tmp/ root@192.168.56.102:/home/
5. Для работы с удаленным сервером там должен быть установлен и настроен сервер rsync.
{% endcapture %}
<div class="notice--info">{{ notice-2 | markdownify }}</div>
</input-file></domains.list></d></ctrl></enter></div>
<br/><br/><br/><br/>
<h2 id="Практика: Работа с файлами"> Практика: Работа с файлами</h2>
<p> В этой работе вы познакомитесь с полезными приемами работы с файлами - созданием жестких и символических ссылок, командами архивации файлов.</p>
<div>
  ### Практическая работа - работа с файлами в Linux


#### Цель работы

Ознакомиться со структурой файловой системы Линукс, типами файлов и командами управления файловой системой.


#### Задания к выполнению



1. В домашнем каталоге создать подкаталоги src, dst и temp;
2. В каталоге temp создать файлы user.txt, root. txt и stud.txt произвольного содержания;
3. В каталог src скопировать файлы user.txt, root. txt и stud.txt, различного содержания;
4. В каталоге dst создать «жесткие» ссылки на все файлы из каталога src;
5. В домашнем каталоге создать «мягкие» ссылки на файлы из каталога src;
6. Вывести рекурсивно расширенную информацию о содержимом домашнего каталога. Обратить внимание на поле размера для физических файлов и ссылок;
7. Из домашнего каталога выполнить команды:

```bash
cat src/user.txt
cat dst/user.txt
cat user.txt
```

8. Заархивируйте содержимое папки src/ в архив .tar.gz.
9. Распакуйте этот архив в директорию \~/backup
10. Выведите названия всех файлов домашней директории, имеющих в названии .txt (подсказка: используйте команду find);
11. Удалите файл user.txt. Что произошло со ссылками на него?
12. Удалите каталог dst;
13. Переместите каталог temp в src;
14. Рекурсивно удалите каталог src



#### Методические указания


##### Организация файловой системы

Файловая система ОС Линукс (как и прочих unix-подобных систем) устроена так, что все ресурсы представлены единообразно, в виде файлов. Такой подход позволяет обеспечить универсальный интерфейс доступа к любым ресурсам: от физических устройств, до процессов, выполняющихся в системе. С точки зрения пользователя файловая система представляет логическую структуру каталогов и файлов. С другой стороны, невидимой пользователю, внутреннее устройство файловой системы реализует физические операции чтения/записи файлов на различные носители, алгоритмы доступа и многое другое.


##### Типы файлов

Для обеспечения единообразного доступа к файлам их прежде всего необходимо классифицировать. В Линукс это сделано следующим образом:



* обычные (regular) файлы - текстовые, исполняемые, графические и пр. файлы, создаваемые пользователями и прикладными программами;
* каталоги (directories) - именованные группы файлов и вложенных каталогов (т.е. содержимое каталога - файлы и другие каталоги);
* файлы устройств (devices) - соответствуют присутствующим в системе реальным (жесткие диски, принтеры, мыши, ЦП и т.д.) устройствам и т. н. псевдоустройствам (например, /dev/null). Файлы устройств представляют символьные (последовательного доступа) и блочные (произвольного доступа) устройства. К первыми относятся, например, параллельные и последовательные порты, ко вторым - жесткие диски;
* специальные файлы - сокеты (sockets) и именованные каналы (named pipes), которые предназначены для обмена информацией между процессами;
* символьные ссылки (symlinks) - именованные указатели на физические файлы (аналог ярлыков ОС Windows), содержащие только путь к некоторому файлу. Символьные ссылки могут указывать на файлы, хранящиеся как локальных, так и в сетевых каталогах.
* Символьные ссылки (или "мягкие") не нужно путать с "жесткими", которые указывают на inode файла. Inode (идентификатор узла) - это уникальный числовой идентификатор узла (файла или каталога) файловой системы, по которому и осуществляется доступ к нему. Символьное имя файла (включая полный путь) ориентировано на пользовательское восприятие. Для человека-оператора проще запомнить осмысленные имена файлов (например: report.txt, myfoto.jpg и т.п.), чем абстрактные числовые значения. Прочие отличия "жестких" и "мягких" ссылок вам предстоит выяснить в ходе выполнения этой лабораторной работы.


##### Каталоги Линукс

Все файлы упорядочены по каталогам. Структура и назначение каждого из каталогов, созданных на этапе установке предопределены, хотя и могут быть (что не стоит делать без крайней необходимости) изменены суперпользователем.

Файловая система имеет иерархическую структуру и начинается от корневого каталога (/). Его подкаталогами являются:



* /bin - исполняемые файлы общего назначения;
* /boot - содержит образ загружаемого ядра;
* /dev - файлы устройств;
* /etc - конфигурационные файлы общего пользования;
* /home - домашние каталоги пользователей, включая программы и файлы личных предпочтений;
* /lib - общесистемные библиотеки;
* /mnt - каталог монтирования внешних файловых систем;
* /proc - виртуальная файловая система для чтения информации о процессах;
* /root - домашний каталог суперпользователя;
* /sbin - программы системного администрирования;
* /tmp - каталог для хранения временной информации;
* /usr - каталог пользовательских прикладных программ со всеми их исполнимыми и конфигурационными файлами. Например, в подкаталог /usr/local инсталлируются программы, не входящие в дистрибутив Линукс, или собираемые из исходных текстов.
* /var - каталог для хранения часто изменяющихся файлов. Например, спулера печати, различных лог-файлов, почтовых сообщений и т.п.
* /lost+found - каталог для нарушенных фрагментов файлов, обнаруженных в результате проверки файловой системы после сбоя.

Такая структура типична для большинства дистрибутивов Линукс, но могут иметься и дополнительные каталоги. Например, /opt - для дополнительных компонентов, /selinux - расширение системы безопасности и т.п.


##### Именование файлов и каталогов

Файловая система Линукс поддерживает "длинные" имена, содержащие символы латиницы, национальных алфавитов, знаки пунктуации и спецсимволы. Абсолютно запрещенными к использованию в имени являются прямой и обратный слэши (/ и \). Максимальное количество символов в имени - 255. Понятие "расширения файла" в unix-системах отсутствует как таковое, поэтому в имени может быть несколько частей, разделенных точками. Все имена - регистрозависимые.

Приведенные выше правила справедливы и для каталогов.

Файлы и каталоги, названия которых начинаются с точки (т.н. dot-файлы), являются аналогами "скрытых" файлов Windows. То есть по умолчанию они не отображаются при просмотре содержимого файловой системы.

Для быстрого доступа к файлам в оболочке имеются несколько переменных окружения, хранящих соответствующие пути. Это, например, переменная $HOME, в которой содержится пути к домашнему каталогу текущего пользователя. Т.е. действия команд


```bash
$ cd /home/usr1
````

и

```bash
$ cd $HOME
```

приведут к одному результату - переходу в домашний каталог пользователя usr1. Более того, в оболочке определен псевдоним для домашнего каталога - символ ~ (тильда) можно использовать аналогично $HOME. Например:


```bash
$ cd ~ 
$ pwd 
/home/usr1 
```

Некоторые другие возможности оболочки будут рассмотрены в следующих лабораторных работах. Дополнительная информация доступна в справочном руководстве bash (man bash).


##### Команды управления файловой системой

Для управления файловой системой имеются различные команды, реализующие операции по созданию, чтению, копированию, переименованию/перемещению, изменению и удалению файлов и каталогов. Как правило, это специализированные команды, хорошо выполняющие свою задачу, однако некоторые функции могут частично дублироваться другими командами, что только добавляет гибкости управлению файлами.

Основными командами для выполнения файловых операций являются: pwd, ls, cp, mv, dir, rm, cd, rmdir, mkdir, ln. Информацию о их назначении и параметрах доступна в формате man и info.

Несколько слов о способах создания файлов в Линукс:



* во-первых, файлы могут быть созданы как результаты работы прикладных программ и иметь определенный формат (например, графические файлы, созданные редактором GIMP);
* во-вторых, файлы могут быть созданы пользователем путем ввода информации с клавиатуры, например так:


```bash
$ cat &gt; f1 
Hello, world! // нажатие Ctrl+D завершает ввод команд 
aag@stilo:~&gt; 
```


* в-третьих, файлы могут быть созданы путем перенаправления вывода команды со стандартного потока, например так:


```bash
# echo "Hello, World!" &gt; f1 
```

В первом и втором случаях символ "&gt;" - это команда перенаправления стандартных потоков ввода/вывода, встроенная в оболочку. В первом случае она получает информацию со стандартного потока ввода (клавиатура) и, по окончании ввода (Ctrl+D), отправляет ее в файл. Во втором - принимает строку, переданную командой echo и также отправляет ее в файл. Если файл отсутствует, то он будет создан, если имеется, то будет перезаписан. Для добавления информации в файл следует использовать команду "&gt;&gt;". Больше информации о командах перенаправления можно получить в справке о возможностях оболочки.


#### Контрольные вопросы



1. Чем отличаются жесткие и символические ссылки?
2. Что произойдет с жесткой ссылкой, если удалить исходный файл? А с символической?
3. Совпадает ли размер символьных и жестких ссылок?
4. Пусть в системе имеется каталог "\~/test". Что произойдет при попытке выполнить следующую команду: "cp \~/test \~/test/newdir"?
5. Какие основные форматы архивов принято использовать в Linux? Какими командами можно пользоваться для создания / открытия этих архивов?


#### Дополнительные задания



1. Настройте автоматическую инкрементальную архивацию домашнего каталога. Для этого создайте команду архивирования всех файлов, измененных за последние сутки и добавьте ее на автоматическое выполнение при помощи службы cron.
2. Измените программу из предыдущего пункта так, чтобы пользователь мог опциями изменять настройки программы:
    1. Задавать папку, откуда происходит копирование;
    2. Задавать расположение архивов;
    3. Задавать частоту архивации;
    4. Исключать определенные типы файлов;
    5. (*) Передавать список папок и типов файлов, которые включаются в общий архив.
</div>
<br/><br/><br/><br/>
</section>
<footer class="page__meta">
<p class="page__taxonomy">
<strong><i aria-hidden="true" class="fas fa-fw fa-folder-open"></i> Разделы: </strong>
<span itemprop="keywords">
<a class="page__taxonomy-item" href="/categories/#os" rel="tag">os</a>
</span>
</p>
<p class="page__date"><strong><i aria-hidden="true" class="fas fa-fw fa-calendar-alt"></i> Дата изменения:</strong> <time datetime="2022-09-27T12:49:07+00:00">September 27, 2022</time></p>
</footer>
<nav class="pagination">
<a class="pagination--pager" href="/os/1/0-vm_installation/" title="LX0 Введение в ОС Linux
">Предыдущая</a>
<a class="pagination--pager" href="/os/1/2-ssh/" title="LX2 Использование удаленного доступа по SSH
">Следующая</a>
</nav>
</div>
</article>
</div>
</div>
<div class="page__footer" id="footer">
<footer>
<!-- start custom footer snippets -->
<!-- end custom footer snippets -->
<div class="page__footer-follow">
<ul class="social-icons">
<li><strong>Связаться со мной:</strong></li>
<li><a href="https://vk.com/koroteev_m" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-vk"></i> Vkontakte</a></li>
<li><a href="https://twitter.com/koroteev_m" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i> Twitter</a></li>
<li><a href="/feed.xml"><i aria-hidden="true" class="fas fa-fw fa-rss-square"></i> RSS-лента</a></li>
</ul>
</div>
<div class="page__footer-copyright">© 2022 Михаил Коротеев. Сайт работает на <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>
</footer>
</div>
<script src="/assets/js/main.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1K09X3NDBE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1K09X3NDBE', { 'anonymize_ip': false});
</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(77706580, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img alt="" src="https://mc.yandex.ru/watch/77706580" style="position:absolute; left:-9999px;"/></div></noscript>
<!-- /Yandex.Metrika counter -->
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
</body>
</html>
